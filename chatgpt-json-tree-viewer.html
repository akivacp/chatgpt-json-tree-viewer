<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multiverse Viewer v5.0 - Supports OpenAI & DeepSeek</title>

<style>
:root{
  /* Dynamically replaced by JS */
  --top-nav-height: 75px;
  /* Color variables for the graph */
  --color-user: #3B82F6;
  --color-assistant: #10A37F;
  --color-system: #666;
  --color-other: #8B5CF6;
  --color-highlight: #FFD700;
  --color-ancestor: #1E90FF;
  --color-descendant: #32CD32;
  --color-dim: rgba(0, 0, 0, 0.1);
  --color-selected: #FF4081; /* Pink color for selected node */
  
  /* Theme variables - default to dark */
  --bg-primary: #2c3e50;
  --bg-secondary: #34495e;
  --bg-sidebar: linear-gradient(to bottom, #2c3e50, #34495e);
  --bg-graph: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  --text-primary: #ecf0f1;
  --text-secondary: #95a5a6;
  --border-color: #1a252f;
  --hover-bg: rgba(255,255,255,0.1);
  --card-bg: rgba(255,255,255,0.05);
  --shadow-color: rgba(0,0,0,0.3);
  --right-panel-bg: linear-gradient(to bottom, #2c3e50, #34495e);
  --right-panel-text: #ecf0f1;
}

/* Light theme */
.light-theme {
  --bg-primary: #ffffff;
  --bg-secondary: #f8f9fa;
  --bg-sidebar: linear-gradient(to bottom, #ffffff, #f8f9fa);
  --bg-graph: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
  --text-primary: #2c3e50;
  --text-secondary: #6c757d;
  --border-color: #dee2e6;
  --hover-bg: rgba(0,0,0,0.05);
  --card-bg: rgba(0,0,0,0.03);
  --shadow-color: rgba(0,0,0,0.1);
  --right-panel-bg: linear-gradient(to bottom, #ffffff, #f8f9fa);
  --right-panel-text: #2c3e50;
}

/* Blue theme */
.blue-theme {
  --bg-primary: #1a237e;
  --bg-secondary: #283593;
  --bg-sidebar: linear-gradient(to bottom, #1a237e, #283593);
  --bg-graph: linear-gradient(135deg, #0d47a1 0%, #1976d2 100%);
  --text-primary: #e8eaf6;
  --text-secondary: #9fa8da;
  --border-color: #3949ab;
  --hover-bg: rgba(255,255,255,0.1);
  --card-bg: rgba(255,255,255,0.05);
  --shadow-color: rgba(0,0,0,0.4);
  --right-panel-bg: linear-gradient(to bottom, #1a237e, #283593);
  --right-panel-text: #e8eaf6;
}

/* Green theme */
.green-theme {
  --bg-primary: #1b5e20;
  --bg-secondary: #2e7d32;
  --bg-sidebar: linear-gradient(to bottom, #1b5e20, #2e7d32);
  --bg-graph: linear-gradient(135deg, #2e7d32 0%, #4caf50 100%);
  --text-primary: #e8f5e9;
  --text-secondary: #a5d6a7;
  --border-color: #388e3c;
  --hover-bg: rgba(255,255,255,0.1);
  --card-bg: rgba(255,255,255,0.05);
  --shadow-color: rgba(0,0,0,0.4);
  --right-panel-bg: linear-gradient(to bottom, #1b5e20, #2e7d32);
  --right-panel-text: #e8f5e9;
}

/* Purple theme */
.purple-theme {
  --bg-primary: #4a148c;
  --bg-secondary: #6a1b9a;
  --bg-sidebar: linear-gradient(to bottom, #4a148c, #6a1b9a);
  --bg-graph: linear-gradient(135deg, #7b1fa2 0%, #ab47bc 100%);
  --text-primary: #f3e5f5;
  --text-secondary: #ce93d8;
  --border-color: #8e24aa;
  --hover-bg: rgba(255,255,255,0.1);
  --card-bg: rgba(255,255,255,0.05);
  --shadow-color: rgba(0,0,0,0.4);
  --right-panel-bg: linear-gradient(to bottom, #4a148c, #6a1b9a);
  --right-panel-text: #f3e5f5;
}

/* =============================== */
/*            GLOBAL               */
/* =============================== */

html, body{
  height: 100%;
}

body{
  margin: 0;
  overflow: hidden;
  background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  transition: background-color 0.3s ease;
}

button{
  font-family: inherit;
}

/* =============================== */
/*             TOP BAR             */
/* =============================== */

#topNav{
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  background: linear-gradient(to right, var(--bg-primary), var(--bg-secondary));
  border-bottom: 1px solid var(--border-color);
  padding: 10px 20px;
  display: flex;
  align-items: center;
  gap: 20px;
  z-index: 100000;
  box-shadow: 0 4px 12px var(--shadow-color);
}

#loadJsonBtn,
#resetLayoutBtn,
#closeConversationBtn{
  background: linear-gradient(to right, #10a37f, #0e8e6c);
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
#loadJsonBtn:hover,
#resetLayoutBtn:hover,
#closeConversationBtn:hover{
  background: linear-gradient(to right, #0e8e6c, #0c7a5c);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

#closeConversationBtn {
  background: linear-gradient(to right, #ef4444, #dc2626);
  display: none;
}

#closeConversationBtn:hover {
  background: linear-gradient(to right, #dc2626, #b91c1c);
}

#fileLabel{
  font-size: 14px;
  color: var(--text-primary);
  user-select: none;
  font-weight: 500;
}

#conversionStatus{
  font-size: 12px;
  color: var(--text-secondary);
  padding: 4px 10px;
  background: var(--card-bg);
  border-radius: 6px;
  display: none;
}

/* Theme selector */
#themeSelector {
  margin-left: auto;
  margin-right: 10px;
  position: relative;
}

#themeBtn {
  background: var(--card-bg);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
  padding: 8px 16px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.3s ease;
}

#themeBtn:hover {
  background: var(--hover-bg);
}

#themeDropdown {
  position: absolute;
  top: 100%;
  right: 0;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 8px 20px var(--shadow-color);
  padding: 8px 0;
  display: none;
  z-index: 100001;
  min-width: 150px;
}

.theme-option {
  padding: 8px 16px;
  color: var(--text-primary);
  cursor: pointer;
  font-size: 13px;
  transition: background 0.3s ease;
  display: flex;
  align-items: center;
  gap: 8px;
}

.theme-option:hover {
  background: var(--hover-bg);
}

.theme-option.active {
  background: rgba(16, 163, 127, 0.2);
  color: #10a37f;
  font-weight: 600;
}

.theme-option .theme-icon {
  width: 16px;
  height: 16px;
  border-radius: 4px;
}

/* =============================== */
/*        DEVELOPER TOOLS          */
/* =============================== */

#devToolsContainer{
  position: relative;
}

#devToolsBtn{
  background: var(--card-bg);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
  padding: 8px 16px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.3s ease;
}

#devToolsBtn:hover{
  background: var(--hover-bg);
}

#devToolsMenu{
  position: absolute;
  top: 42px;
  left: 0;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 8px 20px var(--shadow-color);
  padding: 12px;
  display: none;
  z-index: 100001;
  min-width: 240px;
}

.devToolsRow{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--text-primary);
  margin: 8px 0;
}

.devToolsRow input[type="checkbox"] {
  accent-color: #10a37f;
}

.devToolsRow input[type="range"] {
  width: 80px;
  accent-color: #10a37f;
}

.devToolsRow .range-value {
  min-width: 40px;
  text-align: right;
  font-size: 12px;
  color: var(--text-secondary);
}

/* =============================== */
/*           LEFT SIDEBAR          */
/* =============================== */

#leftSidebar{
  position: fixed;
  top: var(--top-nav-height);
  left: 0;
  width: 260px;
  height: calc(100vh - var(--top-nav-height));
  background: var(--bg-sidebar);
  border-right: 1px solid var(--border-color);
  overflow-y: auto;
  z-index: 9999;
  box-shadow: 2px 0 10px var(--shadow-color);
  transition: width 0.3s ease;
  overflow-x: hidden; /* Prevent horizontal overflow */
}

/* Collapsible section headers */
.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 15px 10px 15px;
  cursor: pointer;
  user-select: none;
  color: var(--text-primary);
  font-weight: 600;
  font-size: 13px;
  transition: background 0.3s ease;
  background: var(--card-bg);
  width: 100%;
  box-sizing: border-box;
  min-width: 0; /* Prevent overflow */
}

.section-header:hover {
  background: var(--hover-bg);
}

.section-header .toggle-icon {
  font-size: 12px;
  color: var(--text-secondary);
  transition: transform 0.3s ease;
  flex-shrink: 0; /* Prevent icon from being cut off */
}

.section-header.collapsed .toggle-icon {
  transform: rotate(-90deg);
}

.section-content {
  padding: 0 15px 15px 15px;
  background: var(--card-bg);
  overflow: hidden;
  transition: all 0.3s ease;
  width: 100%;
  box-sizing: border-box;
  min-width: 0; /* Prevent overflow */
}

.section-content.collapsed {
  padding: 0 15px;
  max-height: 0;
  opacity: 0;
}

/* Search section */
#searchContainer {
  padding: 0;
  background: transparent;
  border-bottom: none;
  width: 100%;
  box-sizing: border-box;
  min-width: 0;
}

#searchBar{
  width: calc(100% - 24px); /* Account for padding */
  margin: 0;
  padding: 10px 12px;
  font-size: 14px;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background: var(--card-bg);
  color: var(--text-primary);
  box-sizing: border-box;
  transition: all 0.3s ease;
  min-width: 0; /* Prevent overflow */
  max-width: 100%;
}

#searchBar:focus {
  outline: none;
  border-color: #10a37f;
  box-shadow: 0 0 0 2px rgba(16, 163, 127, 0.2);
}

#searchBar::placeholder {
  color: var(--text-secondary);
}

#leftSearchResults{
  max-height: 200px;
  overflow-y: auto;
  margin-top: 10px;
  width: 100%;
  box-sizing: border-box;
  min-width: 0;
}

.search-result-item{
  padding: 12px;
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  margin-bottom: 10px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text-primary);
  transition: all 0.3s ease;
  width: 100%;
  box-sizing: border-box;
  min-width: 0;
  word-wrap: break-word;
  overflow-wrap: break-word;
}
.search-result-item:hover{
  background: rgba(16, 163, 127, 0.2);
  border-color: #10a37f;
  transform: translateX(5px);
}

.search-result-item b {
  color: #10a37f;
  display: block;
  margin-bottom: 5px;
  word-wrap: break-word;
}

/* Conversations section */
.conversation-item {
  padding: 12px;
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  margin-bottom: 10px;
  cursor: pointer;
  font-size: 12px;
  color: var(--text-primary);
  transition: all 0.3s ease;
  position: relative;
  width: 100%;
  box-sizing: border-box;
  min-width: 0;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.conversation-item:hover {
  background: rgba(33, 150, 243, 0.2);
  border-color: rgba(33, 150, 243, 0.3);
  transform: translateX(3px);
}

.conversation-item.active {
  background: rgba(16, 163, 127, 0.25);
  border-color: #10a37f;
  box-shadow: 0 0 0 1px #10a37f;
}

.conversation-item.has-search-matches {
  background: rgba(255, 193, 7, 0.15);
  border-color: rgba(255, 193, 7, 0.3);
  border-left: 4px solid #ffc107;
}

.conversation-item.has-search-matches .search-match-count {
  display: inline-block;
  background: #ffc107;
  color: #2c3e50;
  font-size: 10px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 10px;
  margin-left: 5px;
}

.conversation-item .date {
  color: var(--text-secondary);
  font-size: 11px;
  margin-bottom: 4px;
  display: block;
}

.conversation-item .title {
  font-weight: 600;
  margin-bottom: 4px;
  display: block;
  color: var(--text-primary);
  word-wrap: break-word;
}

.conversation-item .meta {
  color: var(--text-secondary);
  font-size: 11px;
  display: block;
}

.conversations-empty {
  padding: 15px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 13px;
  font-style: italic;
  background: var(--card-bg);
  border-radius: 8px;
  border: 1px dashed var(--border-color);
  width: 100%;
  box-sizing: border-box;
  min-width: 0;
}

.conversations-loading {
  padding: 15px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 13px;
  background: var(--card-bg);
  border-radius: 8px;
  border: 1px dashed var(--border-color);
  width: 100%;
  box-sizing: border-box;
  min-width: 0;
}

.conversations-loading::after {
  content: '';
  animation: loading-dots 1.5s infinite;
}

@keyframes loading-dots {
  0%, 20% { content: '.'; }
  40% { content: '..'; }
  60%, 100% { content: '...'; }
}

/* =============================== */
/*        RIGHT VIEWER PANEL       */
/* =============================== */

#rightViewer{
  position: fixed;
  top: var(--top-nav-height);
  right: 0;
  width: 420px;
  height: calc(100vh - var(--top-nav-height));
  background: var(--right-panel-bg);
  border-left: 1px solid var(--border-color);
  overflow-y: auto;
  z-index: 9999;
  box-shadow: -2px 0 10px var(--shadow-color);
  color: var(--right-panel-text);
}

/* Sticky header for viewer */
#viewerHeader {
  position: sticky;
  top: 0;
  background: var(--bg-secondary);
  z-index: 100;
  box-shadow: 0 4px 12px var(--shadow-color);
  padding-bottom: 10px;
  border-bottom: 1px solid var(--border-color);
}

#viewerTabs{
  display: flex;
  gap: 8px;
  padding: 12px;
  background: var(--card-bg);
  border-bottom: 1px solid var(--border-color);
}

.viewerTab{
  padding: 8px 16px;
  background: var(--card-bg);
  border-radius: 8px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  user-select: none;
  transition: all 0.3s ease;
  border: 1px solid transparent;
  color: var(--text-primary);
}
.viewerTab:hover {
  background: var(--hover-bg);
  transform: translateY(-2px);
}
.viewerTab.active{
  background: linear-gradient(to right, #10a37f, #0e8e6c);
  color: white;
  border-color: #0c7a5c;
  box-shadow: 0 2px 8px rgba(16, 163, 127, 0.3);
}

.viewerSubTab{
  padding: 6px 12px;
  background: var(--card-bg);
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
  user-select: none;
  margin: 2px;
  transition: all 0.3s ease;
  border: 1px solid var(--border-color);
  color: var(--text-primary);
}
.viewerSubTab:hover {
  background: var(--hover-bg);
  transform: translateY(-1px);
}
.viewerSubTab.active{
  background: linear-gradient(to right, #4CAF50, #45a049);
  color: white;
  border-color: #3d8b40;
  box-shadow: 0 2px 6px rgba(76, 175, 80, 0.3);
}

#viewerButtons{
  display: flex;
  gap: 10px;
  margin: 15px;
  flex-wrap: wrap;
  position: sticky;
  top: 65px;
  background: var(--bg-primary);
  padding: 12px;
  z-index: 99;
  border-radius: 8px;
  box-shadow: 0 2px 8px var(--shadow-color);
  border: 1px solid var(--border-color);
}

#viewerButtons button{
  background: linear-gradient(to right, #10a37f, #0e8e6c);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 8px 16px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

#viewerButtons button:hover{
  background: linear-gradient(to right, #0e8e6c, #0c7a5c);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

#copyBtn,
#exportBtn,
#popoutBtn,
#pdfBtn{
  display: inline-block;
}

/* Branch index sidebar */
#branchIndexContainer {
  position: fixed;
  top: 120px;
  right: 425px;
  width: 250px;
  background: var(--bg-sidebar);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: 0 8px 25px var(--shadow-color);
  z-index: 1000;
  transition: all 0.3s ease;
  max-height: 70vh;
  overflow: hidden;
}

#branchIndexContainer.collapsed {
  width: 50px;
  height: 50px;
  overflow: hidden;
}

#branchIndexToggle {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
  background: linear-gradient(to right, #10a37f, #0e8e6c);
  border-bottom: 1px solid #0c7a5c;
  cursor: pointer;
  font-weight: bold;
  font-size: 14px;
  color: white;
  transition: all 0.3s ease;
}

#branchIndexToggle:hover {
  background: linear-gradient(to right, #0e8e6c, #0c7a5c);
}

#branchIndexContainer.collapsed #branchIndexToggle {
  border-bottom: none;
  height: 100%;
  border-radius: 12px;
}

#branchIndexSearch {
  padding: 12px;
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border-color);
}

#branchIndexSearch input {
  width: 100%;
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  background: var(--card-bg);
  color: var(--text-primary);
  font-size: 13px;
  box-sizing: border-box;
}

#branchIndexSearch input:focus {
  outline: none;
  border-color: #10a37f;
  box-shadow: 0 0 0 2px rgba(16, 163, 127, 0.2);
}

#branchIndexSearch input::placeholder {
  color: var(--text-secondary);
}

#branchIndex {
  max-height: calc(70vh - 110px);
  overflow-y: auto;
  padding: 10px;
}

.branch-index-item {
  padding: 10px;
  margin: 6px 0;
  background: var(--card-bg);
  border-radius: 8px;
  cursor: pointer;
  font-size: 13px;
  border-left: 4px solid var(--border-color);
  transition: all 0.3s ease;
  color: var(--text-primary);
}

.branch-index-item:hover {
  background: rgba(33, 150, 243, 0.2);
  border-left-color: #2196F3;
  transform: translateX(5px);
}

.branch-index-item.current {
  background: rgba(76, 175, 80, 0.2);
  border-left-color: #4CAF50;
  font-weight: bold;
  color: var(--text-primary);
}

.branch-index-item b {
  color: #10a37f;
  display: block;
  margin-bottom: 4px;
}

#viewerContent{
  padding: 20px;
  font-size: 14px;
  white-space: normal;
  min-height: 200px;
  background: var(--card-bg);
  border-radius: 8px;
  margin: 15px;
  box-shadow: 0 2px 8px var(--shadow-color);
  color: var(--text-primary);
}

/* Message highlight for jumping */
.message.highlighted {
  animation: highlight-pulse 2s ease-in-out;
  box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.5);
  position: relative;
  z-index: 1;
}

@keyframes highlight-pulse {
  0% { 
    box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.5);
    transform: scale(1);
  }
  50% { 
    box-shadow: 0 0 0 8px rgba(255, 193, 7, 0.2);
    transform: scale(1.01);
  }
  100% { 
    box-shadow: 0 0 0 3px rgba(255, 193, 7, 0);
    transform: scale(1);
  }
}

/* =============================== */
/*            MAIN GRAPH           */
/* =============================== */

#graph{
  position: fixed;
  left: 260px;
  top: var(--top-nav-height);
  width: calc(100vw - 260px - 420px);
  height: calc(100vh - var(--top-nav-height));
  background: var(--bg-graph);
  overflow: hidden;
}

/* Graph background pattern - dark theme */
#graph::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: 
    radial-gradient(circle at 25% 25%, rgba(255,255,255,0.05) 2px, transparent 2px),
    radial-gradient(circle at 75% 75%, rgba(255,255,255,0.05) 2px, transparent 2px);
  background-size: 50px 50px;
  pointer-events: none;
}

/* Light theme graph background */
.light-theme #graph::before {
  background-image: 
    radial-gradient(circle at 25% 25%, rgba(0,0,0,0.05) 2px, transparent 2px),
    radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 2px, transparent 2px);
}

/* =============================== */
/*             MINIMAP             */
/* =============================== */

#minimap{
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 200px;
  height: 150px;
  background: rgba(255,255,255,0.9);
  border: 2px solid rgba(0,0,0,0.2);
  border-radius: 10px;
  z-index: 999;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  backdrop-filter: blur(5px);
}

.light-theme #minimap {
  background: rgba(255,255,255,0.95);
  border: 2px solid rgba(0,0,0,0.1);
}

/* =============================== */
/*        DRAG HANDLES (PANELS)    */
/* =============================== */

.drag-handle{
  position: absolute;
  width: 8px;
  cursor: ew-resize;
  top: 0;
  bottom: 0;
  background: linear-gradient(to right, rgba(0,0,0,0.1), rgba(0,0,0,0.3));
  z-index: 1000000;
  transition: background 0.3s ease;
}

.drag-handle:hover {
  background: linear-gradient(to right, rgba(16, 163, 127, 0.5), rgba(16, 163, 127, 0.7));
}

.light-theme .drag-handle {
  background: linear-gradient(to right, rgba(0,0,0,0.05), rgba(0,0,0,0.1));
}

.light-theme .drag-handle:hover {
  background: linear-gradient(to right, rgba(16, 163, 127, 0.3), rgba(16, 163, 127, 0.5));
}

#leftDragHandle{
  right: 0;
}

#rightDragHandle{
  left: 0;
}

/* =============================== */
/*              TOOLTIP            */
/* =============================== */

#tooltip{
  position: absolute;
  max-width: 400px;
  max-height: 400px;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
  box-shadow: 0 8px 25px var(--shadow-color);
  z-index: 999999;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  color: var(--text-primary);
  backdrop-filter: blur(10px);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#tooltipContent {
  max-height: 300px;
  overflow-y: auto;
  padding-right: 5px;
}

#tooltipContent::-webkit-scrollbar {
  width: 6px;
}

#tooltipContent::-webkit-scrollbar-track {
  background: var(--card-bg);
  border-radius: 3px;
}

#tooltipContent::-webkit-scrollbar-thumb {
  background: #10a37f;
  border-radius: 3px;
}

#tooltipCopyBtn {
  position: absolute;
  top: 8px;
  right: 8px;
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 4px 8px;
  font-size: 11px;
  color: var(--text-primary);
  cursor: pointer;
  z-index: 10;
  display: none;
}

#tooltip:hover #tooltipCopyBtn {
  display: block;
}

#tooltipCopyBtn:hover {
  background: rgba(16, 163, 127, 0.2);
  border-color: #10a37f;
}

/* =============================== */
/*            NODES/LINKS           */
/* =============================== */

.node-circle{
  cursor: grab;
  transition: all 0.3s ease;
  pointer-events: all;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}
.node-circle:active{
  cursor: grabbing;
}

.node-circle:hover {
  filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));
  transform: scale(1.1);
}

.node-text{
  font-size: 11px;
  font-weight: 600;
  fill: white;
  cursor: pointer;
  user-select: none;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
  paint-order: stroke;
  stroke: rgba(0,0,0,0.5);
  stroke-width: 2px;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.light-theme .node-text {
  fill: #2c3e50;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
  stroke: rgba(255,255,255,0.5);
}

.node-text:hover{
  fill: var(--color-highlight);
  text-decoration: none;
  font-size: 12px;
}

.match-check{
  font-size: 20px;
  fill: limegreen;
  pointer-events: none;
  filter: drop-shadow(0 0 8px limegreen);
}

/* =============================== */
/*           SEARCH HIGHLIGHT      */
/* =============================== */

@keyframes pulse{
  0%{ 
    transform: scale(1);
    filter: drop-shadow(0 0 6px #ffcc00);
  }
  50%{ 
    transform: scale(1.1);
    filter: drop-shadow(0 0 12px #ffcc00);
  }
  100%{ 
    transform: scale(1);
    filter: drop-shadow(0 0 6px #ffcc00);
  }
}

.node.search-match circle{
  stroke: #ffcc00 !important;
  stroke-width: 6px !important;
  filter: drop-shadow(0 0 10px #ffcc00) !important;
  animation: pulse 1.5s infinite ease-in-out;
}

.node.search-match text{
  fill: #ffcc00 !important;
  font-weight: bold;
}

/* =============================== */
/*       SELECTED NODE HIGHLIGHT   */
/* =============================== */

@keyframes selected-pulse {
  0% { 
    stroke-width: 6px;
    filter: drop-shadow(0 0 20px #FF4081) drop-shadow(0 0 30px #FF4081);
  }
  50% { 
    stroke-width: 8px;
    filter: drop-shadow(0 0 30px #FF4081) drop-shadow(0 0 40px #FF4081);
  }
  100% { 
    stroke-width: 6px;
    filter: drop-shadow(0 0 20px #FF4081) drop-shadow(0 0 30px #FF4081);
  }
}

.selected-node circle{
  stroke: var(--color-selected) !important; /* Pink color for selected node */
  stroke-width: 6px !important;
  filter: drop-shadow(0 0 20px #FF4081) drop-shadow(0 0 30px #FF4081) !important;
  animation: selected-pulse 2s infinite ease-in-out !important;
  z-index: 1000 !important;
}

.selected-node text{
  fill: var(--color-selected) !important; /* Pink color for text */
  font-weight: bold !important;
  font-size: 12px !important;
}

/* Larger circle for selected nodes */
.node.selected-node .node-circle {
  r: 26px !important; /* Larger than normal nodes */
}

/* When a node is both selected AND a search match, selected style wins */
.node.search-match.selected-node circle{
  stroke: var(--color-selected) !important; /* Selected color overrides search color */
  animation: selected-pulse 2s infinite ease-in-out !important;
  r: 26px !important; /* Keep larger size */
}

.node.search-match.selected-node text{
  fill: var(--color-selected) !important; /* Selected color overrides search color */
}

/* =============================== */
/*       ANCESTOR/DESCENDANT       */
/* =============================== */

@keyframes ancestor-pulse {
  0% { 
    stroke-width: 4px;
    filter: drop-shadow(0 0 8px #1E90FF);
  }
  50% { 
    stroke-width: 5px;
    filter: drop-shadow(0 0 12px #1E90FF);
  }
  100% { 
    stroke-width: 4px;
    filter: drop-shadow(0 0 8px #1E90FF);
  }
}

.ancestor-node circle{
  stroke: #1E90FF !important;
  stroke-width: 4px !important;
  filter: drop-shadow(0 0 10px #1E90FF) !important;
  animation: ancestor-pulse 2.5s infinite ease-in-out;
}

@keyframes descendant-pulse {
  0% { 
    stroke-width: 4px;
    filter: drop-shadow(0 0 8px #32CD32);
  }
  50% { 
    stroke-width: 5px;
    filter: drop-shadow(0 10px 12px #32CD32);
  }
  100% { 
    stroke-width: 4px;
    filter: drop-shadow(0 0 8px #32CD32);
  }
}

.descendant-node circle{
  stroke: #32CD32 !important;
  stroke-width: 4px !important;
  filter: drop-shadow(0 0 10px #32CD32) !important;
  animation: descendant-pulse 2.5s infinite ease-in-out;
}

.dim-node{
  opacity: 0.15;
  transition: opacity 0.3s ease;
}

.highlight-faded .selected-node,
.highlight-faded .ancestor-node,
.highlight-faded .descendant-node{
  opacity: 0.4 !important;
}

.link {
  stroke: rgba(255,255,255,0.6);
  stroke-width: 2;
  transition: all 0.3s ease;
  filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
}

.light-theme .link {
  stroke: rgba(0,0,0,0.4);
  filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
}

.link:hover {
  stroke: rgba(255,255,255,0.9);
  stroke-width: 3;
}

.light-theme .link:hover {
  stroke: rgba(0,0,0,0.7);
}

/* =============================== */
/*          SYSTEM NODE STYLE      */
/* =============================== */

.system-node .node-circle{
  fill: none !important;
  stroke: var(--color-system) !important;
  stroke-width: 3px !important;
  stroke-dasharray: 5,5;
}

/* =============================== */
/*        BRANCH CONVERSATION      */
/* =============================== */
.branch-conversation .user-message {
  border-left: 6px solid var(--color-user);
  background: linear-gradient(to right, rgba(59, 130, 246, 0.05), rgba(59, 130, 246, 0.1));
}

.branch-conversation .assistant-message {
  border-left: 6px solid var(--color-assistant);
  background: linear-gradient(to right, rgba(16, 163, 127, 0.05), rgba(16, 163, 127, 0.1));
}

.branch-conversation .system-message {
  border-left: 6px solid var(--color-system);
  background: linear-gradient(to right, rgba(102, 102, 102, 0.05), rgba(102, 102, 102, 0.1));
}

.branch-conversation .other-message {
  border-left: 6px solid var(--color-other);
  background: linear-gradient(to right, rgba(139, 92, 246, 0.05), rgba(139, 92, 246, 0.1));
}

.branch-conversation .message-content pre {
  background: linear-gradient(to right, var(--bg-primary), var(--bg-secondary));
  padding: 15px;
  border-radius: 8px;
  overflow-x: auto;
  font-family: 'JetBrains Mono', 'Consolas', 'Monaco', monospace;
  font-size: 0.9em;
  position: relative;
  color: var(--text-primary);
  border: 1px solid var(--border-color);
}

.branch-conversation .message-content code {
  background: rgba(44, 62, 80, 0.1);
  padding: 3px 6px;
  border-radius: 4px;
  font-family: 'JetBrains Mono', 'Consolas', 'Monaco', monospace;
  color: var(--text-primary);
  font-weight: 500;
}

.branch-conversation .message-content blockquote {
  border-left: 4px solid #3498db;
  margin: 15px 0;
  padding-left: 20px;
  color: var(--text-secondary);
  font-style: italic;
  background: rgba(52, 152, 219, 0.05);
  padding: 10px 15px;
  border-radius: 0 8px 8px 0;
}

/* Code block copy button */
.code-block-wrapper {
  position: relative;
  margin: 15px 0;
}

.code-copy-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0.8));
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 6px 12px;
  font-size: 12px;
  color: var(--text-primary);
  cursor: pointer;
  opacity: 0;
  transition: all 0.3s ease;
  z-index: 10;
  font-weight: 600;
  box-shadow: 0 2px 4px var(--shadow-color);
}

.code-block-wrapper:hover .code-copy-btn {
  opacity: 1;
}

.code-copy-btn:hover {
  background: linear-gradient(to bottom, rgba(76, 175, 80, 0.9), rgba(76, 175, 80, 0.8));
  color: white;
  border-color: rgba(76, 175, 80, 0.3);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px var(--shadow-color);
}

.code-copy-btn.copied {
  background: linear-gradient(to bottom, #4CAF50, #45a049);
  color: white;
  border-color: #3d8b40;
}

/* =============================== */
/*              PRINT             */
/* =============================== */

@media print{
  body, html{
    margin: 0 !important;
    padding: 0 !important;
    height: auto !important;
    overflow: visible !important;
  }

  body *{
    visibility: hidden !important;
    height: 0 !important;
    overflow: hidden !important;
  }

  #rightViewer, #rightViewer *{
    visibility: visible !important;
    height: auto !important;
    overflow: visible !important;
  }

  #rightViewer{
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    width: 100% !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0 !important;
    margin: 0 !important;
  }

  #viewerTabs, #subTabsContainer, #viewerButtons, #branchIndexContainer{
    display: none !important;
  }

  #viewerContent{
    padding: 20px !important;
    font-size: 14px !important;
    overflow: visible !important;
  }

  #graph, svg, canvas, #minimap, #leftSidebar{
    display: none !important;
    height: 0 !important;
  }
}
</style>
</head>

<body>
  <div id="topNav">
    <button id="loadJsonBtn">Load Conversation JSON</button>
    <button id="resetLayoutBtn">Reset Layout</button>
    <button id="closeConversationBtn">Close Conversation</button>

    <div id="devToolsContainer">
      <button id="devToolsBtn">Developer Tools â–¼</button>
      <div id="devToolsMenu">
        <label class="devToolsRow">
          <input type="checkbox" id="toggleSystemNodes">
          <span>Show system nodes</span>
        </label>
        <label class="devToolsRow">
          <input type="checkbox" id="toggleFormatDetection" checked>
          <span>Auto-format detection</span>
        </label>
        <label class="devToolsRow">
          <input type="checkbox" id="toggleTooltip" checked>
          <span>Show tooltips</span>
        </label>
        <label class="devToolsRow">
          <span>Tooltip timer (ms)</span>
          <input type="range" id="tooltipTimerRange" min="500" max="10000" step="500" value="2000">
          <span class="range-value" id="tooltipTimerValue">2000</span>
        </label>
      </div>
    </div>

    <div id="fileLabel">(no file loaded)</div>
    <div id="conversionStatus"></div>
    
    <div id="themeSelector">
      <button id="themeBtn">Themes â–¼</button>
      <div id="themeDropdown">
        <div class="theme-option active" data-theme="dark">
          <div class="theme-icon" style="background: #2c3e50;"></div>
          <span>Dark</span>
        </div>
        <div class="theme-option" data-theme="light">
          <div class="theme-icon" style="background: #ffffff; border: 1px solid #ccc;"></div>
          <span>Light</span>
        </div>
        <div class="theme-option" data-theme="blue">
          <div class="theme-icon" style="background: #1a237e;"></div>
          <span>Blue</span>
        </div>
        <div class="theme-option" data-theme="green">
          <div class="theme-icon" style="background: #1b5e20;"></div>
          <span>Green</span>
        </div>
        <div class="theme-option" data-theme="purple">
          <div class="theme-icon" style="background: #4a148c;"></div>
          <span>Purple</span>
        </div>
      </div>
    </div>

    <div id="formatBadge" style="
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 6px;
      background: linear-gradient(to right, #10a37f, #0e8e6c);
      color: white;
      font-weight: 600;
      display: none;
    "></div>
  </div>

  <div id="leftSidebar">
    <!-- Search Messages Section -->
    <div class="section-header" id="searchSectionHeader" data-section="search">
      <span>Search Messages</span>
      <span class="toggle-icon">â–¼</span>
    </div>
    <div class="section-content" id="searchSectionContent">
      <div id="searchContainer">
        <input id="searchBar" type="text" placeholder="Search all messages..." />
      </div>
      <div id="leftSearchResults"></div>
    </div>
    
    <!-- Conversations Section -->
    <div class="section-header" id="conversationsSectionHeader" data-section="conversations">
      <span>Conversations</span>
      <span class="toggle-icon">â–¼</span>
    </div>
    <div class="section-content" id="conversationsSectionContent">
      <div id="conversationsList" class="conversations-empty">
        Load a conversations.json file to see conversations
      </div>
    </div>
    
    <div id="leftDragHandle" class="drag-handle"></div>
  </div>

  <div id="rightViewer">
    <div id="viewerHeader">
      <div id="viewerTabs">
        <div class="viewerTab active" data-mode="node">Selected Node</div>
        <div class="viewerTab" data-mode="branch">Branch Conversation</div>
      </div>
      
      <div id="subTabsContainer" style="padding: 10px 15px; background: var(--card-bg); border-bottom: 1px solid var(--border-color); display: flex; gap: 8px; flex-wrap: wrap;">
        <div class="viewerSubTab active" data-submode="rendered">Rendered</div>
        <div class="viewerSubTab" data-submode="markdown">Markdown</div>
        <div class="viewerSubTab" data-submode="html">HTML</div>
        <div class="viewerSubTab" data-submode="original">Original</div>
      </div>

      <div id="viewerButtons">
        <button id="copyBtn">Copy</button>
        <button id="exportBtn">Export</button>
        <button id="popoutBtn">Pop-Out</button>
        <button id="pdfBtn">PDF</button>
      </div>
    </div>

    <div id="viewerContent"><div style="color: var(--text-secondary); text-align: center; padding: 40px; font-style: italic;">Select a node to view its content.</div></div>
    <div id="rightDragHandle" class="drag-handle"></div>
  </div>

  <!-- Branch Index Sidebar -->
  <div id="branchIndexContainer" class="collapsed">
    <div id="branchIndexToggle">ðŸ“‹</div>
    <div id="branchIndexSearch" style="display: none;">
      <div style="position: relative;">
        <input type="text" id="branchSearchInput" placeholder="Search in branch..." style="width: 100%; padding-right: 30px; box-sizing: border-box;" />
        <button id="clearBranchSearch" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 16px; padding: 2px 5px;">Ã—</button>
      </div>
    </div>
    <div id="branchIndex"></div>
  </div>

  <svg id="graph"></svg>
  <canvas id="minimap"></canvas>
  <div id="tooltip">
    <button id="tooltipCopyBtn">Copy</button>
    <div id="tooltipContent"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <script>
  /* =============================== */
  /*        FORMAT DETECTION         */
  /* =============================== */
  
  const FORMATS = {
    OPENAI_MULTIVERSE: "openai_multiverse",
    DEEPSEEK_EXPORTER: "deepseek_exporter",
    OPENAI_CONVERSATIONS_ARRAY: "openai_conversations_array",
    UNKNOWN: "unknown"
  };

  let currentFormat = FORMATS.UNKNOWN;
  let originalJSON = null;
  let convertedJSON = null;
  let conversationsList = []; // Store all conversations from conversations.json
  let currentConversationIndex = -1;
  let searchResultsAcrossAllConversations = []; // Store search results across all conversations
  let currentTheme = 'dark'; // Default theme
  let showTooltips = true; // Default to showing tooltips
  let tooltipLingerMs = 2000; // Default tooltip timer

  function detectFormat(json) {
    // Check if it's an array of conversations (OpenAI conversations.json)
    if (Array.isArray(json) && json.length > 0) {
      // Check first item to see if it's a conversation object
      const firstItem = json[0];
      if (firstItem && typeof firstItem === 'object' && firstItem.mapping) {
        return FORMATS.OPENAI_CONVERSATIONS_ARRAY;
      }
    }
    
    // Check for OpenAI multiverse format (single conversation)
    if (json && 
        typeof json === 'object' && 
        json.mapping && 
        typeof json.mapping === 'object') {
      return FORMATS.OPENAI_MULTIVERSE;
    }
    
    // Check for DeepSeek exporter format
    if (json && 
        typeof json === 'object' && 
        json.metadata && 
        json.metadata.platform === "DeepSeek" &&
        Array.isArray(json.messages)) {
      return FORMATS.DEEPSEEK_EXPORTER;
    }
    
    // Check for wrapped OpenAI format
    if (findConversationInJSON(json)) {
      return FORMATS.OPENAI_MULTIVERSE;
    }
    
    return FORMATS.UNKNOWN;
  }

  function formatToMultiverse(json, format) {
    originalJSON = json;
    
    if (format === FORMATS.OPENAI_CONVERSATIONS_ARRAY) {
      // Handle conversations array - extract all conversations
      conversationsList = extractConversationsFromArray(json);
      updateFormatBadge(FORMATS.OPENAI_CONVERSATIONS_ARRAY);
      
      // Load the first conversation by default
      if (conversationsList.length > 0) {
        updateConversationsList();
        const firstConv = sanitizeConversation(conversationsList[0].data);
        convertedJSON = firstConv;
        currentConversationIndex = 0;
        return firstConv;
      } else {
        throw new Error("No valid conversations found in array");
      }
    }
    
    if (format === FORMATS.OPENAI_MULTIVERSE) {
      const found = findConversationInJSON(json);
      if (!found) throw new Error("Could not find conversation in OpenAI format");
      convertedJSON = sanitizeConversation(found);
      return convertedJSON;
    }
    
    if (format === FORMATS.DEEPSEEK_EXPORTER) {
      return convertDeepSeekToMultiverse(json);
    }
    
    throw new Error(`Unsupported format: ${format}`);
  }

  /* =============================== */
  /*     CONVERSATIONS ARRAY HANDLING */
  /* =============================== */
  
  function extractConversationsFromArray(jsonArray) {
    const conversations = [];
    
    jsonArray.forEach((conv, index) => {
      if (!conv || !conv.mapping) return;
      
      // Extract conversation info
      const title = conv.title || `Untitled Conversation ${index + 1}`;
      const createTime = conv.create_time || Date.now() / 1000;
      const messageCount = Object.keys(conv.mapping).length;
      const conversationId = conv.conversation_id || `conv_${index}`;
      
      // Format date for display
      const date = new Date(createTime * 1000);
      const formattedDate = date.toISOString().split('T')[0]; // YYYY-MM-DD
      
      conversations.push({
        index: index,
        id: conversationId,
        title: title,
        createTime: createTime,
        formattedDate: formattedDate,
        messageCount: messageCount,
        data: conv,
        raw: conv,
        searchMatches: 0 // Track search matches per conversation
      });
    });
    
    // Sort by creation time (newest first)
    conversations.sort((a, b) => b.createTime - a.createTime);
    
    return conversations;
  }
  
  function updateConversationsList(searchQuery = '') {
    const listContainer = document.getElementById('conversationsList');
    
    if (conversationsList.length === 0) {
      listContainer.innerHTML = '<div class="conversations-empty">Load a conversations.json file to see conversations</div>';
      return;
    }
    
    let html = '';
    
    // Separate conversations with matches and without matches
    const conversationsWithMatches = [];
    const conversationsWithoutMatches = [];
    
    conversationsList.forEach((conv, index) => {
      const isActive = index === currentConversationIndex;
      const hasMatches = conv.searchMatches > 0;
      
      if (hasMatches) {
        conversationsWithMatches.push({conv, index, isActive});
      } else {
        conversationsWithoutMatches.push({conv, index, isActive});
      }
    });
    
    // Sort conversations with matches by match count (descending)
    conversationsWithMatches.sort((a, b) => b.conv.searchMatches - a.conv.searchMatches);
    
    // Display conversations with matches first
    conversationsWithMatches.forEach(({conv, index, isActive}) => {
      const activeClass = isActive ? 'active' : '';
      const hasMatches = conv.searchMatches > 0;
      const matchesClass = hasMatches ? 'has-search-matches' : '';
      const date = conv.formattedDate;
      const title = conv.title.length > 50 ? conv.title.substring(0, 50) + '...' : conv.title;
      const messageCount = conv.messageCount;
      
      html += `
        <div class="conversation-item ${activeClass} ${matchesClass}" data-index="${index}">
          <span class="date">${date}</span>
          <span class="title">${title}</span>
          <span class="meta">
            ${messageCount} message${messageCount !== 1 ? 's' : ''}
            ${hasMatches ? `<span class="search-match-count">${conv.searchMatches}</span>` : ''}
          </span>
        </div>
      `;
    });
    
    // Display conversations without matches, sorted by date (newest first)
    conversationsWithoutMatches.sort((a, b) => b.conv.createTime - a.conv.createTime);
    
    conversationsWithoutMatches.forEach(({conv, index, isActive}) => {
      const activeClass = isActive ? 'active' : '';
      const date = conv.formattedDate;
      const title = conv.title.length > 50 ? conv.title.substring(0, 50) + '...' : conv.title;
      const messageCount = conv.messageCount;
      
      html += `
        <div class="conversation-item ${activeClass}" data-index="${index}">
          <span class="date">${date}</span>
          <span class="title">${title}</span>
          <span class="meta">
            ${messageCount} message${messageCount !== 1 ? 's' : ''}
          </span>
        </div>
      `;
    });
    
    listContainer.innerHTML = html;
    
    // Add click handlers for conversation items
    document.querySelectorAll('.conversation-item').forEach(item => {
      item.addEventListener('click', function() {
        const index = parseInt(this.dataset.index);
        loadConversation(index);
      });
    });
  }
  
  function loadConversation(index) {
    if (index < 0 || index >= conversationsList.length) return;
    
    currentConversationIndex = index;
    
    // Clear search results in current conversation
    clearSearchMatches();
    
    // Clear viewer panel
    document.getElementById('viewerContent').innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 40px; font-style: italic;">Select a node to view its content.</div>';
    
    // Load the conversation
    const conv = conversationsList[index];
    convertedJSON = sanitizeConversation(conv.data);
    lastLoadedJSON = convertedJSON;
    
    // Update UI
    updateConversationsList();
    buildTree(convertedJSON);
    
    // Update file label
    const fileName = document.getElementById('fileLabel').innerText;
    if (fileName.includes('conversations.json')) {
      document.getElementById('fileLabel').innerText = `${fileName} (${index + 1}/${conversationsList.length})`;
    }
    
    // Clear branch index
    document.getElementById('branchIndex').innerHTML = '';
    
    // Show close button
    document.getElementById('closeConversationBtn').style.display = 'inline-block';
    
    // If there's a search query, apply it to the newly loaded conversation
    const searchQuery = document.getElementById('searchBar').value.trim();
    if (searchQuery) {
      performSearchInCurrentConversation(searchQuery);
    }
  }
  
  function closeConversation() {
    // Clear current conversation
    currentConversationIndex = -1;
    lastLoadedJSON = null;
    convertedJSON = null;
    
    // Clear everything
    document.getElementById('viewerContent').innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 40px; font-style: italic;">Select a node to view its content.</div>';
    document.getElementById('fileLabel').innerText = '(no file loaded)';
    document.getElementById('closeConversationBtn').style.display = 'none';
    document.getElementById('formatBadge').style.display = 'none';
    
    // Clear graph
    const svg = d3.select("#graph");
    svg.selectAll("*").remove();
    
    // Clear search
    document.getElementById('searchBar').value = '';
    document.getElementById('leftSearchResults').innerHTML = '';
    clearSearchMatches();
    
    // Hide branch index
    document.getElementById('branchIndexContainer').style.display = 'none';
    
    // Update conversation list to remove active state
    updateConversationsList();
  }

  /* =============================== */
  /*     CROSS-CONVERSATION SEARCH   */
  /* =============================== */
  
  function performCrossConversationSearch(query) {
    searchResultsAcrossAllConversations = [];
    
    if (!query) {
      // Clear all search highlights
      conversationsList.forEach(conv => {
        conv.searchMatches = 0;
      });
      updateConversationsList();
      clearSearchMatches();
      document.getElementById('leftSearchResults').innerHTML = '';
      return;
    }
    
    const lowerQuery = query.toLowerCase();
    let totalMatches = 0;
    
    // Search through all conversations
    conversationsList.forEach((conv, convIndex) => {
      const mapping = conv.data.mapping;
      let conversationMatches = 0;
      
      // Search within this conversation
      Object.keys(mapping).forEach(nodeId => {
        const node = mapping[nodeId];
        const msg = node.message;
        const text = extractText(msg);
        
        if (text && text.toLowerCase().includes(lowerQuery)) {
          conversationMatches++;
          totalMatches++;
          
          // Store search result
          searchResultsAcrossAllConversations.push({
            conversationIndex: convIndex,
            conversationTitle: conv.title,
            conversationDate: conv.formattedDate,
            nodeId: nodeId,
            nodeRole: msg?.author?.role || 'unknown',
            nodeText: text.substring(0, 200) + (text.length > 200 ? '...' : ''),
            fullText: text
          });
        }
      });
      
      // Update conversation with match count
      conv.searchMatches = conversationMatches;
    });
    
    // Update conversation list with highlights and proper sorting
    updateConversationsList(query);
    
    // Update search results panel
    updateSearchResultsPanel();
    
    // If we're viewing a conversation that has matches, highlight them
    if (currentConversationIndex >= 0 && conversationsList[currentConversationIndex]?.searchMatches > 0) {
      performSearchInCurrentConversation(query);
    }
  }
  
  function performSearchInCurrentConversation(query) {
    if (!query || !allNodes || allNodes.length === 0) {
      clearSearchMatches();
      document.getElementById('leftSearchResults').innerHTML = '';
      return;
    }
    
    const lowerQuery = query.toLowerCase();
    const leftResults = document.getElementById('leftSearchResults');
    leftResults.innerHTML = '';
    
    clearSearchMatches();
    
    // Search within current conversation nodes
    allNodes.forEach(n => {
      const text = String(n.data.text || "").toLowerCase();
      const match = text.includes(lowerQuery);
      
      if (match) {
        // Highlight node on graph
        g.selectAll(".node")
          .filter(d => d === n)
          .select(".match-check")
          .style("display", "block");
        
        g.selectAll(".node")
          .filter(d => d === n)
          .classed("search-match", true);
        
        // Add to search results panel
        addSearchResultItem(n);
      }
    });
  }
  
  function updateSearchResultsPanel() {
    const leftResults = document.getElementById('leftSearchResults');
    
    if (searchResultsAcrossAllConversations.length === 0) {
      leftResults.innerHTML = '<div style="padding: 10px; text-align: center; color: var(--text-secondary); font-size: 12px;">No matches found</div>';
      return;
    }
    
    let html = `<div style="padding: 10px; margin-bottom: 10px; background: var(--card-bg); border-radius: 8px; font-size: 12px; color: var(--text-secondary);">
      Found ${searchResultsAcrossAllConversations.length} match${searchResultsAcrossAllConversations.length !== 1 ? 'es' : ''} across ${conversationsList.filter(c => c.searchMatches > 0).length} conversation${conversationsList.filter(c => c.searchMatches > 0).length !== 1 ? 's' : ''}
    </div>`;
    
    // Group results by conversation
    const resultsByConversation = {};
    searchResultsAcrossAllConversations.forEach(result => {
      if (!resultsByConversation[result.conversationIndex]) {
        resultsByConversation[result.conversationIndex] = {
          conversation: conversationsList[result.conversationIndex],
          results: []
        };
      }
      resultsByConversation[result.conversationIndex].results.push(result);
    });
    
    // Display results grouped by conversation
    Object.keys(resultsByConversation).forEach(convIndex => {
      const group = resultsByConversation[convIndex];
      const isCurrentConversation = parseInt(convIndex) === currentConversationIndex;
      
      html += `<div style="margin-bottom: 15px; background: var(--card-bg); border-radius: 8px; overflow: hidden;">
        <div style="padding: 10px; background: var(--hover-bg); font-weight: 600; font-size: 12px; display: flex; justify-content: space-between; align-items: center;">
          <span>${group.conversation.title}</span>
          <span style="font-size: 11px; color: var(--text-secondary);">${group.results.length} match${group.results.length !== 1 ? 'es' : ''}</span>
        </div>
        <div style="padding: 5px;">`;
      
      group.results.forEach(result => {
        const roleIcon = result.nodeRole === 'user' ? 'ðŸ‘¤' : result.nodeRole === 'assistant' ? 'ðŸ¤–' : 'â“';
        html += `
          <div class="search-result-item" data-conversation-index="${convIndex}" data-node-id="${result.nodeId}">
            <b>${roleIcon} ${result.nodeRole.toUpperCase()}</b>
            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 3px;">
              ${result.nodeText}
            </div>
          </div>
        `;
      });
      
      html += `</div></div>`;
    });
    
    leftResults.innerHTML = html;
    
    // Add click handlers to search result items
    document.querySelectorAll('.search-result-item').forEach(item => {
      item.addEventListener('click', function() {
        const convIndex = parseInt(this.dataset.conversationIndex);
        const nodeId = this.dataset.nodeId;
        
        // If clicking a result from a different conversation, switch to it
        if (convIndex !== currentConversationIndex) {
          loadConversation(convIndex);
          
          // Wait for the conversation to load, then find and highlight the node
          setTimeout(() => {
            findAndHighlightNode(nodeId, convIndex);
          }, 300);
        } else {
          // Already in the right conversation, just find and highlight the node
          findAndHighlightNode(nodeId, convIndex);
        }
      });
    });
  }
  
  function findAndHighlightNode(nodeId, convIndex) {
    // Find the node in the current conversation's allNodes array
    const node = allNodes.find(n => n.data.id === nodeId);
    
    if (node) {
      // Center on the node and highlight it
      centerOnNode(node);
      handleNodeClick(node);
      openViewerPanel(node);
      
      // Also ensure it's highlighted as a search match
      g.selectAll(".node")
        .filter(d => d === node)
        .select(".match-check")
        .style("display", "block");
      
      g.selectAll(".node")
        .filter(d => d === node)
        .classed("search-match", true);
    }
  }

  /* =============================== */
  /*     COLLAPSIBLE SECTIONS        */
  /* =============================== */
  
  function initializeCollapsibleSections() {
    // Initialize both sections as expanded
    const sections = ['search', 'conversations'];
    
    sections.forEach(section => {
      const header = document.getElementById(`${section}SectionHeader`);
      const content = document.getElementById(`${section}SectionContent`);
      
      // Set initial state (expanded)
      header.classList.remove('collapsed');
      content.classList.remove('collapsed');
      
      header.addEventListener('click', function() {
        const isCollapsed = this.classList.contains('collapsed');
        
        if (isCollapsed) {
          this.classList.remove('collapsed');
          content.classList.remove('collapsed');
        } else {
          this.classList.add('collapsed');
          content.classList.add('collapsed');
        }
      });
    });
  }

  /* =============================== */
  /*     THEME MANAGEMENT            */
  /* =============================== */
  
  function initializeThemeSystem() {
    // Check for saved theme
    const savedTheme = localStorage.getItem('multiverseTheme') || 'dark';
    
    // Set initial state
    currentTheme = savedTheme;
    
    // Apply theme
    applyTheme(currentTheme);
    
    // Theme selector
    const themeBtn = document.getElementById('themeBtn');
    const themeDropdown = document.getElementById('themeDropdown');
    
    themeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      themeDropdown.style.display = themeDropdown.style.display === 'block' ? 'none' : 'block';
    });
    
    // Theme options
    document.querySelectorAll('.theme-option').forEach(option => {
      option.addEventListener('click', function() {
        const theme = this.dataset.theme;
        
        // Update active state
        document.querySelectorAll('.theme-option').forEach(opt => {
          opt.classList.remove('active');
        });
        this.classList.add('active');
        
        // Apply theme
        applyTheme(theme);
        
        // Close dropdown
        themeDropdown.style.display = 'none';
      });
    });
    
    // Close dropdown when clicking outside
    window.addEventListener('click', () => {
      themeDropdown.style.display = 'none';
    });
    
    // Set active theme option
    document.querySelectorAll('.theme-option').forEach(option => {
      if (option.dataset.theme === currentTheme) {
        option.classList.add('active');
      }
    });
  }
  
  function applyTheme(theme) {
    currentTheme = theme;
    localStorage.setItem('multiverseTheme', theme);
    
    // Remove all theme classes
    document.body.classList.remove('light-theme', 'blue-theme', 'green-theme', 'purple-theme');
    
    // Apply new theme
    if (theme !== 'dark') {
      document.body.classList.add(theme + '-theme');
    }
  }

  /* =============================== */
  /*     DEVELOPER TOOLS SETTINGS    */
  /* =============================== */
  
  function initializeDeveloperTools() {
    // Load saved settings
    const savedShowTooltips = localStorage.getItem('multiverseShowTooltips') !== 'false';
    const savedTooltipTimer = localStorage.getItem('multiverseTooltipTimer') || '2000';
    
    showTooltips = savedShowTooltips;
    tooltipLingerMs = parseInt(savedTooltipTimer);
    
    // Set initial checkbox states
    document.getElementById('toggleTooltip').checked = showTooltips;
    document.getElementById('tooltipTimerRange').value = tooltipLingerMs;
    document.getElementById('tooltipTimerValue').textContent = tooltipLingerMs;
    
    // Tooltip toggle
    document.getElementById('toggleTooltip').addEventListener('change', function(e) {
      showTooltips = e.target.checked;
      localStorage.setItem('multiverseShowTooltips', showTooltips);
    });
    
    // Tooltip timer
    const timerRange = document.getElementById('tooltipTimerRange');
    const timerValue = document.getElementById('tooltipTimerValue');
    
    timerRange.addEventListener('input', function(e) {
      tooltipLingerMs = parseInt(e.target.value);
      timerValue.textContent = tooltipLingerMs;
      localStorage.setItem('multiverseTooltipTimer', tooltipLingerMs);
    });
  }

  /* =============================== */
  /*     REST OF THE FUNCTIONS       */
  /* =============================== */

  function convertDeepSeekToMultiverse(deepseekJson) {
    const mapping = {};
    const messages = deepseekJson.messages || [];
    
    // Create a simple linear chain for DeepSeek conversations
    messages.forEach((msg, index) => {
      const nodeId = `msg_${index}`;
      const prevNodeId = index > 0 ? `msg_${index - 1}` : null;
      const nextNodeId = index < messages.length - 1 ? `msg_${index + 1}` : null;
      
      // Extract content
      let contentText = "";
      if (msg.role === "user") {
        contentText = msg.content || "";
      } else if (msg.role === "assistant") {
        if (typeof msg.content === "object") {
          contentText = msg.content.final_answer || 
                       (msg.content.thinking_chain ? 
                         `${msg.content.thinking_chain}\n\n${msg.content.final_answer || ""}` : 
                         "");
        } else {
          contentText = msg.content || "";
        }
      }
      
      mapping[nodeId] = {
        id: nodeId,
        parent: prevNodeId,
        children: nextNodeId ? [nextNodeId] : [],
        message: {
          id: nodeId,
          author: {
            role: msg.role,
            name: null,
            metadata: {}
          },
          create_time: msg.timestamp ? new Date(msg.timestamp).getTime() / 1000 : Date.now() / 1000,
          content: {
            content_type: "text",
            parts: [contentText]
          },
          status: "finished_successfully",
          metadata: {},
          weight: 1,
          end_turn: true
        },
        _original_data: msg,
        _format: "deepseek"
      };
    });
    
    convertedJSON = {
      title: deepseekJson.metadata?.title || "DeepSeek Conversation",
      create_time: deepseekJson.metadata?.extracted_at ? 
                   new Date(deepseekJson.metadata.extracted_at).getTime() / 1000 : 
                   Date.now() / 1000,
      update_time: deepseekJson.metadata?.extracted_at ? 
                   new Date(deepseekJson.metadata.extracted_at).getTime() / 1000 : 
                   Date.now() / 1000,
      mapping: mapping,
      conversation_id: deepseekJson.metadata?.url?.split('/').pop() || "deepseek_chat",
      _original_format: "deepseek",
      _converted_at: new Date().toISOString()
    };
    
    return convertedJSON;
  }

  function updateFormatBadge(format) {
    const badge = document.getElementById('formatBadge');
    currentFormat = format;
    
    switch(format) {
      case FORMATS.OPENAI_CONVERSATIONS_ARRAY:
        badge.textContent = "Multiple Conversations";
        badge.style.background = "linear-gradient(to right, #8B5CF6, #7C3AED)";
        badge.style.color = "white";
        break;
      case FORMATS.OPENAI_MULTIVERSE:
        badge.textContent = "OpenAI Format";
        badge.style.background = "linear-gradient(to right, #10a37f, #0e8e6c)";
        badge.style.color = "white";
        break;
      case FORMATS.DEEPSEEK_EXPORTER:
        badge.textContent = "DeepSeek Format";
        badge.style.background = "linear-gradient(to right, #0ea5e9, #0d8fd8)";
        badge.style.color = "white";
        break;
      default:
        badge.textContent = "Unknown Format";
        badge.style.background = "linear-gradient(to right, #f44336, #d32f2f)";
        badge.style.color = "white";
    }
    
    badge.style.display = "inline-block";
  }

  /* =============================== */
  /*        AUTO-CONVERSION LOGIC    */
  /* =============================== */
  
  function isMultiverseFormat(json) {
    // Check if JSON has the expected multiverse format
    return json && 
           typeof json === 'object' && 
           json.mapping && 
           typeof json.mapping === 'object' &&
           Object.keys(json.mapping).length > 0;
  }

  function findConversationInJSON(json) {
    // Case 1: Already a multiverse object
    if (json && json.mapping) return json;

    // Case 2: Array of conversations (OpenAI export)
    if (Array.isArray(json)) {
      for (const entry of json) {
        if (entry && typeof entry === "object" && entry.mapping) {
          return entry;
        }
      }
    }

    // Case 3: Could be wrapped in another structure
    if (json && typeof json === 'object') {
      // Try common OpenAI export structures
      const possiblePaths = [
        json.conversation,
        json.data,
        json.chat,
        json.messages
      ];
      
      for (const path of possiblePaths) {
        if (path && path.mapping) return path;
        if (Array.isArray(path)) {
          for (const item of path) {
            if (item && item.mapping) return item;
          }
        }
      }
    }

    return null;
  }

  function sanitizeConversation(convo) {
    if (!convo || !convo.mapping) return convo;

    const map = convo.mapping;

    for (const id in map) {
      const node = map[id];
      const msg = node.message;

      let text = "(empty)";

      if (msg) {
        if (msg.content && Array.isArray(msg.content.parts)) {
          const parts = msg.content.parts.filter(p => p && String(p).trim() !== "");
          text = parts.length ? parts.join("\n") : "(empty)";
        }
        else if (msg.content && msg.content.content_type) {
          text = "[" + msg.content.content_type + "]";
        }
        else if (typeof msg.content === 'string') {
          text = msg.content;
        }
      } else {
        text = "(no message object)";
      }

      // Add cleaned text for viewer
      node._viewerText = text;
    }

    return convo;
  }

  function autoConvertJSON(json) {
    const status = document.getElementById('conversionStatus');
    
    try {
      // Detect format
      const format = detectFormat(json);
      
      if (format === FORMATS.UNKNOWN) {
        status.innerHTML = "âŒ Unrecognized file format";
        status.style.color = "#f44336";
        updateFormatBadge(FORMATS.UNKNOWN);
        throw new Error("Unrecognized file format. Supported: OpenAI multiverse JSON, DeepSeek exporter JSON");
      }
      
      // Update badge
      updateFormatBadge(format);
      
      // Convert to multiverse format
      status.innerHTML = `ðŸ”„ Converting ${format}...`;
      status.style.color = "#ff9800";
      status.style.display = "block";
      
      const converted = formatToMultiverse(json, format);
      
      status.innerHTML = "âœ… File loaded successfully";
      status.style.color = "#10a37f";
      
      return converted;
      
    } catch (err) {
      status.innerHTML = "âŒ Error: " + err.message;
      status.style.color = "#f44336";
      throw err;
    }
  }

  /* =============================== */
  /*        ORIGINAL VIEWER CODE     */
  /* =============================== */

  function updateTopNavHeight(){
    const h = document.getElementById("topNav").offsetHeight;
    document.documentElement.style.setProperty("--top-nav-height", h + "px");
  }
  window.addEventListener("load", updateTopNavHeight);
  window.addEventListener("resize", updateTopNavHeight);

  /* GLOBAL STATE */
  let rootHierarchy = null;
  let originalPositions = new Map();
  let activeNode = null;
  let allNodes = [];
  let allLinks = [];
  let svg, g, zoom;

  const tooltip = document.getElementById("tooltip");
  const tooltipContent = document.getElementById("tooltipContent");
  const tooltipCopyBtn = document.getElementById("tooltipCopyBtn");
  let tooltipHideTimer = null;

  function clearTooltipHideTimer(){
    if (tooltipHideTimer){
      clearTimeout(tooltipHideTimer);
      tooltipHideTimer = null;
    }
  }

  function scheduleTooltipHide(ms = tooltipLingerMs){
    clearTooltipHideTimer();
    tooltipHideTimer = setTimeout(() => {
      tooltip.style.opacity = 0;
      tooltip.style.pointerEvents = "none";
    }, ms);
  }

  function isBracketToken(text){
    const t = String(text || "").trim();
    return /^\[[^\]]+\]$/.test(t);
  }

  tooltip.addEventListener("mouseenter", () => {
    if (!showTooltips) return;
    clearTooltipHideTimer();
    tooltip.style.opacity = 1;
    tooltip.style.pointerEvents = "auto";
  });

  tooltip.addEventListener("mouseleave", () => {
    if (!showTooltips) return;
    scheduleTooltipHide(tooltipLingerMs);
  });

  // Tooltip copy button
  tooltipCopyBtn.addEventListener('click', async function(e) {
    e.stopPropagation();
    const content = tooltipContent.innerHTML;
    
    try {
      // Create a temporary element to get text
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      const text = tempDiv.textContent || tempDiv.innerText || '';
      
      await navigator.clipboard.writeText(text);
      tooltipCopyBtn.textContent = 'Copied!';
      setTimeout(() => {
        tooltipCopyBtn.textContent = 'Copy';
      }, 2000);
    } catch (err) {
      console.error('Failed to copy tooltip content:', err);
      tooltipCopyBtn.textContent = 'Failed';
      setTimeout(() => {
        tooltipCopyBtn.textContent = 'Copy';
      }, 2000);
    }
  });

  let isDragging = false;
  let highlightFadeApplied = false;

  let lastLoadedJSON = null;
  let showSystemNodes = false;

  /* =============================== */
  /*     ENHANCED EXTRACT TEXT       */
  /* =============================== */
  
  function extractText(msg) {
    if (!msg) return "";
    
    // Handle DeepSeek format
    if (msg._original_data) {
      const data = msg._original_data;
      if (data.role === "user") {
        return String(data.content || "").trim();
      } else if (data.role === "assistant") {
        if (typeof data.content === "object") {
          const parts = [];
          if (data.content.search_hint) parts.push(`**${data.content.search_hint}**`);
          if (data.content.thinking_chain) parts.push(`> ${data.content.thinking_chain}`);
          if (data.content.final_answer) parts.push(data.content.final_answer);
          return parts.join("\n\n");
        }
        return String(data.content || "").trim();
      }
    }
    
    // Handle OpenAI format
    if (msg.content && Array.isArray(msg.content.parts)) {
      return msg.content.parts.join("\n");
    }
    if (msg.content && msg.content.content_type && msg.content.content_type !== "text") {
      return "[" + msg.content.content_type + "]";
    }
    
    // Fallback
    if (msg._viewerText) return msg._viewerText;
    
    return "";
  }

  /* DEV TOOLS MENU */
  const devBtn = document.getElementById("devToolsBtn");
  const devMenu = document.getElementById("devToolsMenu");
  const devContainer = document.getElementById("devToolsContainer");
  const toggleSystemNodesCheckbox = document.getElementById("toggleSystemNodes");

  function setDevMenuOpen(open){
    devMenu.style.display = open ? "block" : "none";
    devBtn.setAttribute("aria-expanded", open ? "true" : "false");
  }

  devBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    setDevMenuOpen(devMenu.style.display !== "block");
  });

  window.addEventListener("click", (e) => {
    if (!devContainer.contains(e.target)){
      setDevMenuOpen(false);
    }
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape"){
      setDevMenuOpen(false);
    }
  });

  toggleSystemNodesCheckbox.addEventListener("change", (e) => {
    showSystemNodes = e.target.checked;
    if (lastLoadedJSON) buildTree(lastLoadedJSON);
  });

  /* LOAD JSON BUTTON - WITH AUTO-CONVERSION */
  document.getElementById("loadJsonBtn").addEventListener("click", () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json,application/json";
    input.onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      document.getElementById("fileLabel").innerText = file ? file.name : "(no file loaded)";
      if (!file) return;
      loadJSON(file);
    };
    input.click();
  });

  // Add drag and drop support
  document.getElementById('loadJsonBtn').addEventListener('dragover', function(e) {
    e.preventDefault();
    e.stopPropagation();
    this.style.background = 'linear-gradient(to right, #0c7a5c, #0a6548)';
  });

  document.getElementById('loadJsonBtn').addEventListener('dragleave', function(e) {
    e.preventDefault();
    e.stopPropagation();
    this.style.background = 'linear-gradient(to right, #10a37f, #0e8e6c)';
  });

  document.getElementById('loadJsonBtn').addEventListener('drop', function(e) {
    e.preventDefault();
    e.stopPropagation();
    this.style.background = 'linear-gradient(to right, #10a37f, #0e8e6c)';
    
    const file = e.dataTransfer.files[0];
    if (file && file.type === 'application/json') {
      document.getElementById("fileLabel").innerText = file.name;
      loadJSON(file);
    }
  });

  // Close conversation button
  document.getElementById('closeConversationBtn').addEventListener('click', () => {
    closeConversation();
  });

  function loadJSON(file){
    const reader = new FileReader();
    reader.onload = (e) => {
      try{
        const rawJSON = JSON.parse(String(e.target.result || ""));
        
        // Reset conversations list
        conversationsList = [];
        currentConversationIndex = -1;
        searchResultsAcrossAllConversations = [];
        
        // Auto-convert if needed
        const processedJSON = autoConvertJSON(rawJSON);
        
        lastLoadedJSON = processedJSON;
        buildTree(processedJSON);
        
      }catch (err){
        console.error(err);
        const status = document.getElementById('conversionStatus');
        status.innerHTML = "âŒ Error: " + err.message;
        status.style.color = "#f44336";
        status.style.display = "block";
      }
    };
    reader.readAsText(file);
  }

  /* SYSTEM NODE DETECTION (DATA LEVEL) */
  function isSystemData(data){
    if (!data) return true;
    const role = data.role || "unknown";
    const t = String(data.text || "").trim();

    if (role === "system" && t === "") return true;
    if (t === "") return true;
    if (t.toLowerCase().includes("model_editable_context")) return true;
    if (/^\[[^\]]+\]$/.test(t)) return true;

    return false;
  }

  /* COLLAPSE SYSTEM NODES FROM DATA TREE */
  function collapseSystemNodesTree(node){
    if (!node.children || node.children.length === 0) return node;

    node.children = node.children
      .map(child => collapseSystemNodesTree(child))
      .flatMap(child => {
        if (isSystemData(child)){
          return (child.children && child.children.length) ? child.children : [];
        }
        return [child];
      });

    return node;
  }

  /* ENHANCED BUILD TREE TO HANDLE DEEPSEEK FORMAT */
  function buildTree(json) {
    const map = json.mapping;
    
    // Find root nodes (nodes without parents)
    const rootIds = Object.keys(map).filter(id => !map[id].parent);
    
    // If no root found in OpenAI format, look for DeepSeek linear chain
    if (rootIds.length === 0) {
      // For DeepSeek linear format, find the first message
      const firstId = Object.keys(map).find(id => map[id].parent === null);
      if (firstId) rootIds.push(firstId);
    }
    
    if (!rootIds.length) return;

    function convert(id) {
      const node = map[id];
      return {
        id,
        role: node.message?.author?.role || "unknown",
        text: extractText(node.message),
        rawMessage: node.message || null,
        rawChunk: node || null,
        children: (node.children || []).map(convert)
      };
    }

    let rootData = convert(rootIds[0]);

    if (!showSystemNodes) {
      rootData = collapseSystemNodesTree(rootData);
    }

    renderTree(rootData);
  }

  /* RENDER TREE */
  function renderTree(rootData){
    svg = d3.select("#graph");
    svg.selectAll("*").remove();

    zoom = d3.zoom()
      .scaleExtent([0.001, 100])
      .on("zoom", (e) => {
        g.attr("transform", e.transform);
        updateMinimap();
      });

    svg.call(zoom);

    g = svg.append("g");

    const layout = d3.tree().nodeSize([70, 200]);
    rootHierarchy = d3.hierarchy(rootData);
    layout(rootHierarchy);

    allNodes = rootHierarchy.descendants();
    allLinks = rootHierarchy.links();

    originalPositions = new Map();
    allNodes.forEach(n => {
      originalPositions.set(n, { x: n.x, y: n.y });
      n.data.originalX = n.x;
      n.data.originalY = n.y;
    });

    drawLinks();
    drawNodes();
    fitView();
    updateMinimap();
  }

  /* DRAW LINKS */
  function drawLinks(){
    g.selectAll(".link")
      .data(allLinks)
      .enter()
      .append("path")
      .attr("class", "link")
      .attr("fill", "none")
      .attr("stroke", currentTheme === 'light' ? "rgba(0,0,0,0.4)" : "rgba(255,255,255,0.6)")
      .attr("stroke-width", 2)
      .attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));
  }

  /* DRAW NODES - WITH IMPROVED TEXT POSITIONING AND SELECTED NODE SIZE */
  function drawNodes(){
    const nodes = g.selectAll(".node")
      .data(allNodes)
      .enter()
      .append("g")
      .attr("class", d => {
        let className = "node";
        if (isSystemData(d.data)) className += " system-node";
        return className;
      })
      .attr("transform", d => "translate(" + d.x + "," + d.y + ")")
      .style("z-index", 1); // Base z-index for all nodes

    // Draw circles first with beautiful colors
    nodes.append("circle")
      .attr("class", "node-circle")
      .attr("r", d => {
        if (isSystemData(d.data)) return 10;
        if (d.data.role === "user") return 22;
        if (d.data.role === "assistant") return 20;
        return 18;
      })
      .attr("fill", d => {
        if (isSystemData(d.data)) return "none";
        if (d.data.role === "user") return "url(#user-gradient)";
        if (d.data.role === "assistant") return "url(#assistant-gradient)";
        return "url(#other-gradient)";
      })
      .attr("stroke", d => {
        if (isSystemData(d.data)) return "#666";
        if (d.data.role === "user") return "#1e40af";
        if (d.data.role === "assistant") return "#0c7a5c";
        return "#6d28d9";
      })
      .attr("stroke-width", d => isSystemData(d.data) ? 2 : 3)
      .style("z-index", 1) // Base z-index
      .on("mouseenter", (e, d) => showTooltip(e, d))
      .on("mouseleave", hideTooltip)
      .on("mousedown", () => startDragHighlightFade())
      .call(
        d3.drag()
          .on("drag", (e, d) => dragBranch(e, d))
          .on("end", endDragHighlightFade)
      )
      .on("click", (e, d) => {
        e.stopPropagation();
        centerOnNode(d);
        handleNodeClick(d);
        openViewerPanel(d);
      });

    // Add gradients for beautiful node colors
    const defs = svg.append("defs");
    
    // User gradient (blue)
    const userGradient = defs.append("linearGradient")
      .attr("id", "user-gradient")
      .attr("x1", "0%").attr("y1", "0%")
      .attr("x2", "100%").attr("y2", "100%");
    userGradient.append("stop").attr("offset", "0%").attr("stop-color", "#3B82F6");
    userGradient.append("stop").attr("offset", "100%").attr("stop-color", "#1D4ED8");
    
    // Assistant gradient (green)
    const assistantGradient = defs.append("linearGradient")
      .attr("id", "assistant-gradient")
      .attr("x1", "0%").attr("y1", "0%")
      .attr("x2", "100%").attr("y2", "100%");
    assistantGradient.append("stop").attr("offset", "0%").attr("stop-color", "#10B981");
    assistantGradient.append("stop").attr("offset", "100%").attr("stop-color", "#0C7A5C");
    
    // Other gradient (purple)
    const otherGradient = defs.append("linearGradient")
      .attr("id", "other-gradient")
      .attr("x1", "0%").attr("y1", "0%")
      .attr("x2", "100%").attr("y2", "100%");
    otherGradient.append("stop").attr("offset", "0%").attr("stop-color", "#8B5CF6");
    otherGradient.append("stop").attr("offset", "100%").attr("stop-color", "#6D28D9");

    // Draw text for non-system nodes with content
    const textNodes = nodes.filter(d => !isSystemData(d.data) && d.data.text && String(d.data.text).trim() !== "");
    
    // First pass: create text elements with initial positions
    const textElements = textNodes.append("text")
      .attr("class", "node-text")
      .attr("dy", "0.35em")
      .style("font-size", "11px")
      .style("cursor", "pointer")
      .style("pointer-events", "all")
      .text(d => {
        const t = String(d.data.text).replace(/\n/g, " ");
        return t.length > 30 ? t.slice(0, 30) + "..." : t;
      })
      .on("click", function(e, d) {
        e.stopPropagation();
        centerOnNode(d);
        handleNodeClick(d);
        openViewerPanel(d);
      })
      .on("mouseenter", function(e, d) {
        showTooltip(e, d);
      })
      .on("mouseleave", hideTooltip);

    // Calculate optimal text positions to avoid overlaps
    calculateTextPositions();

    nodes.append("text")
      .attr("class", "match-check")
      .attr("x", -30)
      .attr("y", -30)
      .style("display", "none")
      .text("âœ“");
  }

  /* CALCULATE OPTIMAL TEXT POSITIONS */
  function calculateTextPositions() {
    // Get all text elements
    const textElements = g.selectAll(".node-text").nodes();
    
    // Create bounding boxes for all text elements
    const textBoxes = textElements.map(textEl => {
      const bbox = textEl.getBBox();
      const node = d3.select(textEl).datum();
      return {
        el: textEl,
        node: node,
        x: node.x + bbox.x,
        y: node.y + bbox.y,
        width: bbox.width,
        height: bbox.height,
        originalX: node.x,
        originalY: node.y
      };
    });

    // Sort by Y position (top to bottom)
    textBoxes.sort((a, b) => a.originalY - b.originalY);

    // Adjust positions to avoid overlaps
    for (let i = 0; i < textBoxes.length; i++) {
      const current = textBoxes[i];
      let bestPosition = { x: 28, y: 4 }; // Default position (right side)
      
      // Try different positions
      const positions = [
        { x: 28, y: 4 },    // Right side
        { x: -28, y: 4 },   // Left side
        { x: 0, y: -28 },   // Above
        { x: 0, y: 32 },    // Below
        { x: 45, y: 4 },    // Further right
        { x: -45, y: 4 },   // Further left
        { x: 28, y: -20 },  // Top-right
        { x: -28, y: -20 }, // Top-left
      ];

      // Find the first position that doesn't overlap
      for (const pos of positions) {
        const testBox = {
          x: current.originalX + pos.x,
          y: current.originalY + pos.y,
          width: current.width,
          height: current.height
        };

        let overlaps = false;
        
        // Check overlap with other text boxes
        for (let j = 0; j < i; j++) {
          const other = textBoxes[j];
          if (boxesOverlap(testBox, other)) {
            overlaps = true;
            break;
          }
        }

        // Also check if text would overlap with node positions
        const nearbyNodes = allNodes.filter(n => 
          Math.abs(n.x - current.originalX) < 250 && 
          Math.abs(n.y - current.originalY) < 250
        );

        for (const node of nearbyNodes) {
          const nodeBox = {
            x: node.x - 25, // Node radius + padding
            y: node.y - 25,
            width: 50,
            height: 50
          };
          if (boxesOverlap(testBox, nodeBox)) {
            overlaps = true;
            break;
          }
        }

        if (!overlaps) {
          bestPosition = pos;
          break;
        }
      }

      // Apply the best position
      d3.select(current.el)
        .attr("x", bestPosition.x)
        .attr("y", bestPosition.y)
        .style("text-anchor", bestPosition.x < 0 ? "end" : "start");
    }
  }

  /* CHECK IF TWO BOXES OVERLAP */
  function boxesOverlap(box1, box2) {
    return !(box1.x + box1.width < box2.x ||
             box2.x + box2.width < box1.x ||
             box1.y + box1.height < box2.y ||
             box2.y + box2.height < box1.y);
  }

  /* UPDATE TEXT POSITIONS WHEN NODES ARE DRAGGED */
  function updateTextPositions() {
    // Clear existing text and redraw with new positions
    g.selectAll(".node-text").remove();
    
    const textNodes = g.selectAll(".node")
      .filter(d => !isSystemData(d.data) && d.data.text && String(d.data.text).trim() !== "");
    
    textNodes.append("text")
      .attr("class", "node-text")
      .attr("dy", "0.35em")
      .style("font-size", "11px")
      .style("cursor", "pointer")
      .style("pointer-events", "all")
      .text(d => {
        const t = String(d.data.text).replace(/\n/g, " ");
        return t.length > 30 ? t.slice(0, 30) + "..." : t;
      })
      .on("click", function(e, d) {
        e.stopPropagation();
        centerOnNode(d);
        handleNodeClick(d);
        openViewerPanel(d);
      })
      .on("mouseenter", function(e, d) {
        showTooltip(e, d);
      })
      .on("mouseleave", hideTooltip);
    
    calculateTextPositions();
  }

  /* DRAG BRANCH */
  function dragBranch(event, d){
    isDragging = true;

    const dx = event.dx;
    const dy = event.dy;

    d.x += dx;
    d.y += dy;

    d.data.x = d.x;
    d.data.y = d.y;

    shiftDescendants(d, dx, dy);

    updatePositions();
    updateTextPositions();
    updateMinimap();
  }

  function shiftDescendants(node, dx, dy){
    if (!node.children) return;
    node.children.forEach(c => {
      c.x += dx;
      c.y += dy;
      c.data.x = c.x;
      c.data.y = c.y;
      shiftDescendants(c, dx, dy);
    });
  }

  function updatePositions(){
    g.selectAll(".node").attr("transform", d => "translate(" + d.x + "," + d.y + ")");
    g.selectAll(".link").attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));
  }

  /* HIGHLIGHT LOGIC - UPDATED FOR SELECTED NODE SIZE */
  function handleNodeClick(d){
    if (isDragging){
      isDragging = false;
      return;
    }

    activeNode = d;
    
    // First, clear all highlights
    clearHighlight();
    clearSearchMatches();

    // Get current search query
    const searchQuery = document.getElementById("searchBar").value.trim();
    
    // If there's a search query, reapply search matches first
    if (searchQuery && conversationsList.length > 0) {
      // For multi-conversation files, we need to check if current conversation has matches
      const currentConv = conversationsList[currentConversationIndex];
      if (currentConv && currentConv.searchMatches > 0) {
        performSearchInCurrentConversation(searchQuery);
      }
    } else if (searchQuery) {
      // Single conversation - just reapply search
      performSearchInCurrentConversation(searchQuery);
    }

    // Now apply the selected node and its branch highlights
    const ancestors = d.ancestors();
    const descendants = d.descendants();

    g.selectAll(".node")
      .filter(nd => nd === d)
      .style("z-index", 1000); // Bring selected node to front

    // Apply classes for styling - selected nodes will be larger due to CSS rule
    g.selectAll(".node")
      .classed("selected-node", nd => nd === d)
      .classed("ancestor-node", nd => ancestors.includes(nd) && nd !== d)
      .classed("descendant-node", nd => descendants.includes(nd) && nd !== d)
      .classed("dim-node", nd => !ancestors.includes(nd) && !descendants.includes(nd) && nd !== d);

    openViewerPanel(d);
  }

  function clearHighlight(){
    g.selectAll(".node").style("z-index", 1); // Reset z-index
    g.selectAll(".node").classed("selected-node ancestor-node descendant-node dim-node", false);
  }

  function startDragHighlightFade(){
    if (!highlightFadeApplied){
      g.classed("highlight-faded", true);
      highlightFadeApplied = true;
    }
  }

  function endDragHighlightFade(){
    g.classed("highlight-faded", false);
    highlightFadeApplied = false;
  }

  /* ENHANCED TOOLTIP WITH RENDERED CONTENT AND COPY */
  function showTooltip(event, d){
    if (!showTooltips) return;
    
    clearTooltipHideTimer();

    const text = d.data.text || "(empty)";
    const role = d.data.role || "unknown";
    const roleColor = role === "user" ? "#3B82F6" : role === "assistant" ? "#10A37F" : "#666";
    
    // Render markdown content
    const renderedContent = DOMPurify.sanitize(marked.parse(text));
    
    tooltipContent.innerHTML = `
      <div style="color: ${roleColor}; font-weight: bold; margin-bottom: 5px;">${role.toUpperCase()}</div>
      <div style="max-height: 250px; overflow: auto; font-size: 12px; line-height: 1.4;">
        ${renderedContent}
      </div>
    `;

    // Position tooltip intelligently to stay within bounds
    const tooltipWidth = 400;
    const tooltipHeight = 400;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    let left = event.pageX + 15;
    let top = event.pageY + 15;
    
    // Adjust if tooltip would go off screen
    if (left + tooltipWidth > viewportWidth) {
      left = event.pageX - tooltipWidth - 15;
    }
    if (top + tooltipHeight > viewportHeight) {
      top = event.pageY - tooltipHeight - 15;
    }
    
    tooltip.style.left = left + "px";
    tooltip.style.top = top + "px";
    tooltip.style.pointerEvents = "auto";
    tooltip.style.opacity = 1;

    if (isSystemData(d.data) || isBracketToken(text)){
      openViewerPanel(d, text);
    }
  }

  function hideTooltip(){
    if (!showTooltips) return;
    scheduleTooltipHide(tooltipLingerMs);
  }

  /* SEARCH SYSTEM - UPDATED FOR CROSS-CONVERSATION */
  const searchInput = document.getElementById("searchBar");
  const leftResults = document.getElementById("leftSearchResults");

  searchInput.addEventListener("input", () => {
    const q = String(searchInput.value || "").trim();
    
    if (conversationsList.length > 0) {
      // Multiple conversations loaded - search across all
      performCrossConversationSearch(q);
    } else {
      // Single conversation - search within current
      performSearchInCurrentConversation(q);
    }
  });

  function clearSearchMatches(){
    g.selectAll(".match-check").style("display", "none");
    g.selectAll(".node").classed("search-match", false);
  }

  function addSearchResultItem(n){
    const div = document.createElement("div");
    div.className = "search-result-item";
    const preview = String(n.data.text || "");
    const role = n.data.role || "unknown";
    const roleIcon = role === "user" ? "ðŸ‘¤" : role === "assistant" ? "ðŸ¤–" : "â“";
    
    div.innerHTML = `<b>${roleIcon} Node ${String(n.data.id || "")}</b><br>${preview.slice(0, 80)}${preview.length > 80 ? "..." : ""}`;

    div.onclick = () => {
      centerOnNode(n);
      handleNodeClick(n);
      openViewerPanel(n);
    };

    leftResults.appendChild(div);
  }

  /* CENTER ON NODE */
  function centerOnNode(n){
    const t = d3.zoomIdentity
      .translate(
        window.innerWidth / 2 - n.x,
        window.innerHeight / 4 - n.y
      )
      .scale(1);

    svg.transition().duration(350).call(zoom.transform, t);
  }

  /* =============================== */
  /*     BRANCH CONVERSATION VIEW    */
  /* =============================== */
  
  // Store branch message references for indexing
  let branchMessages = [];

  function getBranchConversation(node) {
    if (!node) return "";
    
    // Get all ancestors including current node
    const ancestors = node.ancestors();
    
    // Store references for indexing
    branchMessages = [];
    
    let html = `<div class="branch-conversation" style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 800px; margin: 0 auto;">`;
    
    // Reverse order so oldest messages are on top
    const reversedAncestors = ancestors.slice().reverse();
    
    reversedAncestors.forEach((n, index) => {
      const data = n.data;
      const msg = extractText(data.rawMessage);
      
      if (!msg || msg.trim() === "") return;
      
      const role = data.role || "unknown";
      const isUser = role === "user";
      const isAssistant = role === "assistant";
      const isSystem = role === "system";
      const isCurrent = n === node;
      
      // Format timestamp if available
      let timestamp = "";
      if (data.rawMessage && data.rawMessage.create_time) {
        const date = new Date(data.rawMessage.create_time * 1000);
        timestamp = date.toLocaleString();
      }
      
      // Create message element with ID for jumping
      const messageId = `branch-msg-${index}`;
      
      // Store reference
      branchMessages.push({
        id: messageId,
        node: n,
        data: data,
        isCurrent: isCurrent,
        index: index
      });
      
      // Determine message class based on role
      let messageClass = "";
      if (isUser) messageClass = "user-message";
      else if (isAssistant) messageClass = "assistant-message";
      else if (isSystem) messageClass = "system-message";
      else messageClass = "other-message";
      
      html += `
        <div id="${messageId}" class="message ${messageClass}" 
             style="margin: 20px 0; padding: 18px; border-radius: 12px; 
                    box-shadow: 0 3px 10px rgba(0,0,0,0.08);">
          
          <div class="message-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div class="message-author" style="font-weight: 600; color: ${isUser ? '#1976d2' : isAssistant ? '#388e3c' : '#666'};">
              ${isUser ? 'ðŸ‘¤ User' : (isAssistant ? 'ðŸ¤– Assistant' : (isSystem ? 'âš™ï¸ System' : 'â“ Unknown'))}
              ${data.id ? `<span style="font-size: 0.8em; color: var(--text-secondary); margin-left: 10px; background: var(--card-bg); padding: 2px 6px; border-radius: 4px;">#${data.id}</span>` : ''}
            </div>
            ${timestamp ? `<div class="message-time" style="font-size: 0.8em; color: var(--text-secondary); background: var(--card-bg); padding: 3px 8px; border-radius: 4px;">${timestamp}</div>` : ''}
          </div>
          
          <div class="message-content" style="line-height: 1.6; color: var(--text-primary);">
            ${addCopyButtonsToCodeBlocks(DOMPurify.sanitize(marked.parse(msg)))}
          </div>
          
          ${isCurrent ? 
            `<div style="margin-top: 12px; padding: 8px 12px; background: linear-gradient(to right, rgba(255, 193, 7, 0.1), rgba(255, 193, 7, 0.05)); border-left: 4px solid #ff9800; font-size: 0.9em; border-radius: 4px;">
              <strong>â†³ Current Node</strong> (selected)
            </div>` : ''}
        </div>
      `;
    });
    
    html += `
      <div class="conversation-summary" style="margin-top: 30px; padding: 20px; background: var(--card-bg); border-radius: 12px; font-size: 0.9em; border: 1px solid var(--border-color);">
        <strong style="color: var(--text-primary); display: block; margin-bottom: 10px;">Conversation Summary:</strong>
        <ul style="margin: 10px 0; padding-left: 20px; color: var(--text-secondary);">
          <li>Total messages in branch: <strong>${ancestors.length}</strong></li>
          <li>User messages: <strong style="color: #1976d2;">${ancestors.filter(n => n.data.role === 'user').length}</strong></li>
          <li>Assistant messages: <strong style="color: #388e3c;">${ancestors.filter(n => n.data.role === 'assistant').length}</strong></li>
          <li>Other messages: <strong style="color: #666;">${ancestors.filter(n => !['user', 'assistant'].includes(n.data.role)).length}</strong></li>
        </ul>
      </div>
    </div>`;
    
    // Update branch index
    updateBranchIndex(reversedAncestors, node);
    
    return html;
  }

  /* =============================== */
  /*     BRANCH INDEX SIDEBAR        */
  /* =============================== */
  
  let branchIndexFilter = "";
  
  function updateBranchIndex(ancestors, currentNode) {
    const branchIndex = document.getElementById('branchIndex');
    const branchIndexContainer = document.getElementById('branchIndexContainer');
    
    branchIndex.innerHTML = '';
    
    let filteredCount = 0;
    
    ancestors.forEach((n, index) => {
      const data = n.data;
      const msg = extractText(data.rawMessage);
      
      if (!msg || msg.trim() === "") return;
      
      const role = data.role || "unknown";
      const isCurrent = n === currentNode;
      const roleIcon = role === 'user' ? 'ðŸ‘¤' : role === 'assistant' ? 'ðŸ¤–' : 'âš™ï¸';
      
      // Filter by search text
      if (branchIndexFilter && !msg.toLowerCase().includes(branchIndexFilter.toLowerCase()) && 
          !role.toLowerCase().includes(branchIndexFilter.toLowerCase()) &&
          !data.id?.toLowerCase().includes(branchIndexFilter.toLowerCase())) {
        return;
      }
      
      filteredCount++;
      
      const div = document.createElement('div');
      div.className = 'branch-index-item' + (isCurrent ? ' current' : '');
      div.innerHTML = `
        <div style="font-weight: ${isCurrent ? 'bold' : '600'}; font-size: 12px; margin-bottom: 4px;">
          ${index + 1}. ${roleIcon} ${data.id || ''}
        </div>
        <div style="font-size: 11px; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
          ${msg.substring(0, 50)}${msg.length > 50 ? '...' : ''}
        </div>
      `;
      
      div.onclick = () => {
        // Switch to branch mode first if we're not already in it
        if (currentMode !== 'branch') {
          switchMode('branch', 'rendered');
          // Wait for the branch conversation to render
          setTimeout(() => {
            jumpToBranchMessage(n, index);
          }, 50);
        } else {
          jumpToBranchMessage(n, index);
        }
      };
      
      branchIndex.appendChild(div);
    });
    
    // Show search count if filtering
    if (branchIndexFilter) {
      const countDiv = document.createElement('div');
      countDiv.style.padding = '8px';
      countDiv.style.fontSize = '11px';
      countDiv.style.color = 'var(--text-secondary)';
      countDiv.style.textAlign = 'center';
      countDiv.style.borderTop = '1px solid var(--border-color)';
      countDiv.innerHTML = `Showing ${filteredCount} of ${ancestors.length} messages`;
      branchIndex.appendChild(countDiv);
    }
    
    // Show the index when in branch mode
    if (currentMode === 'branch') {
      branchIndexContainer.style.display = 'block';
    }
  }

  function jumpToBranchMessage(n, index) {
    // Jump to the message in the branch conversation
    const messageId = `branch-msg-${index}`;
    const messageElement = document.getElementById(messageId);
    
    if (messageElement) {
      // First, ensure we're in branch mode and the conversation is loaded
      if (currentMode !== 'branch' || !currentBranchNode) {
        switchMode('branch', 'rendered');
        setTimeout(() => {
          jumpToMessageElement(messageElement, n);
        }, 100);
      } else {
        jumpToMessageElement(messageElement, n);
      }
    } else {
      // If message element not found, reload the branch conversation
      openViewerPanel(n);
      switchMode('branch', 'rendered');
      
      // Try again after a short delay
      setTimeout(() => {
        const retryElement = document.getElementById(messageId);
        if (retryElement) {
          jumpToMessageElement(retryElement, n);
        }
      }, 200);
    }
  }

  function jumpToMessageElement(messageElement, n) {
    // Highlight the node on the graph
    centerOnNode(n);
    handleNodeClick(n);
    
    // Scroll to the message in the conversation
    messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    // Add visual highlight
    messageElement.classList.add('highlighted');
    setTimeout(() => {
      messageElement.classList.remove('highlighted');
    }, 2000);
    
    // Update current in index
    document.querySelectorAll('.branch-index-item').forEach(item => {
      item.classList.remove('current');
    });
    
    // Find and highlight the corresponding index item
    const indexItems = document.querySelectorAll('.branch-index-item');
    const reversedAncestors = n.ancestors().slice().reverse();
    const itemIndex = reversedAncestors.findIndex(node => node === n);
    
    if (itemIndex >= 0 && indexItems[itemIndex]) {
      indexItems[itemIndex].classList.add('current');
    }
  }

  // Toggle branch index sidebar
  document.getElementById('branchIndexToggle').addEventListener('click', function() {
    const container = document.getElementById('branchIndexContainer');
    const isCollapsed = container.classList.contains('collapsed');
    container.classList.toggle('collapsed');
    this.textContent = isCollapsed ? 'âœ•' : 'ðŸ“‹';
    
    // Show/hide search bar when expanding/collapsing
    const searchBar = document.getElementById('branchIndexSearch');
    searchBar.style.display = isCollapsed ? 'block' : 'none';
  });

  // Branch index search functionality
  document.getElementById('branchSearchInput')?.addEventListener('input', function(e) {
    branchIndexFilter = e.target.value.trim();
    if (currentBranchNode) {
      const ancestors = currentBranchNode.ancestors().slice().reverse();
      updateBranchIndex(ancestors, currentBranchNode);
    }
  });

  // Clear branch search button
  document.getElementById('clearBranchSearch')?.addEventListener('click', function() {
    document.getElementById('branchSearchInput').value = '';
    branchIndexFilter = '';
    if (currentBranchNode) {
      const ancestors = currentBranchNode.ancestors().slice().reverse();
      updateBranchIndex(ancestors, currentBranchNode);
    }
  });

  /* =============================== */
  /*     CODE BLOCK COPY BUTTONS     */
  /* =============================== */
  
  function addCopyButtonsToCodeBlocks(html) {
    // Create a temporary div to parse HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    
    // Find all pre elements that contain code
    const preElements = tempDiv.querySelectorAll('pre');
    
    preElements.forEach(pre => {
      // Check if pre contains a code element
      const codeElement = pre.querySelector('code');
      if (codeElement) {
        // Wrap in a container
        const wrapper = document.createElement('div');
        wrapper.className = 'code-block-wrapper';
        
        // Create copy button
        const copyButton = document.createElement('button');
        copyButton.className = 'code-copy-btn';
        copyButton.textContent = 'Copy';
        
        copyButton.onclick = async function(e) {
          e.stopPropagation();
          const codeText = codeElement.textContent;
          
          try {
            await navigator.clipboard.writeText(codeText);
            copyButton.textContent = 'Copied!';
            copyButton.classList.add('copied');
            
            setTimeout(() => {
              copyButton.textContent = 'Copy';
              copyButton.classList.remove('copied');
            }, 2000);
          } catch (err) {
            console.error('Failed to copy code:', err);
            copyButton.textContent = 'Failed';
            setTimeout(() => {
              copyButton.textContent = 'Copy';
            }, 2000);
          }
        };
        
        // Replace pre with wrapper containing pre and button
        pre.parentNode.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);
        wrapper.appendChild(copyButton);
      }
    });
    
    return tempDiv.innerHTML;
  }

  /* =============================== */
  /*     ENHANCED VIEWER PANEL       */
  /* =============================== */
  let currentMode = "node"; // "node" or "branch"
  let currentSubMode = "rendered"; // "rendered", "markdown", "html", "original"
  let currentRenderedContent = "";
  let currentNodeData = null;
  let currentBranchNode = null;

  function openViewerPanel(n, overrideText) {
    currentNodeData = n && n.data ? n.data : {};
    currentBranchNode = n;
    
    // Get content based on format
    let msg = "";
    let originalData = null;
    
    if (overrideText !== undefined && overrideText !== null) {
      msg = String(overrideText);
    } else if (currentNodeData._original_data) {
      // DeepSeek format
      originalData = currentNodeData._original_data;
      if (typeof originalData.content === "object") {
        // Build comprehensive message
        const parts = [];
        if (originalData.content.search_hint) parts.push(`**${originalData.content.search_hint}**`);
        if (originalData.content.thinking_chain) parts.push(`### Thoughts\n\n> ${originalData.content.thinking_chain}`);
        if (originalData.content.final_answer) parts.push(`### Answer\n\n${originalData.content.final_answer}`);
        msg = parts.join("\n\n");
      } else {
        msg = String(originalData.content || "");
      }
    } else {
      // OpenAI format
      msg = extractText(currentNodeData.rawMessage);
    }

    const rawMsgObj = currentNodeData.rawMessage || {};
    const rawChunkObj = currentNodeData.rawChunk || {};
    const deepseekData = currentNodeData._original_data || {};

    const rawText =
      "Format: " + (currentNodeData._format || "openai") + "\n\n" +
      "Message Data:\n" +
      JSON.stringify(rawMsgObj, null, 2) +
      "\n\n" +
      "Node Data:\n" +
      JSON.stringify(rawChunkObj, null, 2) +
      (Object.keys(deepseekData).length ? 
        "\n\n" + "DeepSeek Original:\n" + JSON.stringify(deepseekData, null, 2) : 
        "");

    const originalJson = originalData || rawMsgObj;

    // Store data for different modes
    window.currentNodeMsg = msg;
    window.currentNodeRawText = rawText;
    window.currentNodeOriginalJson = originalJson;

    // Initialize with node view
    switchMode("node", "rendered");

    // Show action buttons
    document.getElementById("copyBtn").style.display = "inline-block";
    document.getElementById("exportBtn").style.display = "inline-block";
    document.getElementById("popoutBtn").style.display = "inline-block";
    document.getElementById("pdfBtn").style.display = "inline-block";
  }

  function switchMode(mode, subMode = null) {
    currentMode = mode;
    if (subMode) currentSubMode = subMode;

    const content = document.getElementById("viewerContent");
    
    // Update main tabs
    document.querySelectorAll(".viewerTab").forEach(tab => {
      tab.classList.toggle("active", tab.dataset.mode === mode);
    });
    
    // Update sub tabs
    document.querySelectorAll(".viewerSubTab").forEach(tab => {
      tab.classList.toggle("active", tab.dataset.submode === currentSubMode);
    });

    // Set up tab click handlers
    document.querySelectorAll(".viewerTab").forEach(tab => {
      tab.onclick = () => switchMode(tab.dataset.mode);
    });
    
    document.querySelectorAll(".viewerSubTab").forEach(tab => {
      tab.onclick = () => switchMode(currentMode, tab.dataset.submode);
    });

    // Show/hide branch index
    const branchIndexContainer = document.getElementById('branchIndexContainer');
    if (mode === 'branch' && currentBranchNode) {
      branchIndexContainer.style.display = 'block';
      // Expand the index when switching to branch mode
      if (branchIndexContainer.classList.contains('collapsed')) {
        branchIndexContainer.classList.remove('collapsed');
        document.getElementById('branchIndexToggle').textContent = 'âœ•';
        document.getElementById('branchIndexSearch').style.display = 'block';
      }
    } else {
      branchIndexContainer.style.display = 'none';
    }

    // Get content based on current mode
    let displayContent = "";
    
    if (mode === "node") {
      switch(currentSubMode) {
        case "markdown":
          displayContent = window.currentNodeMsg || "";
          currentRenderedContent = displayContent;
          content.innerText = displayContent;
          break;
        case "rendered":
          const html = DOMPurify.sanitize(marked.parse(window.currentNodeMsg || ""));
          displayContent = addCopyButtonsToCodeBlocks(html);
          currentRenderedContent = displayContent;
          content.innerHTML = displayContent;
          break;
        case "html":
          const html2 = DOMPurify.sanitize(marked.parse(window.currentNodeMsg || ""));
          displayContent = html2;
          currentRenderedContent = html2;
          content.innerText = html2;
          break;
        case "original":
          displayContent = JSON.stringify(window.currentNodeOriginalJson || {}, null, 2);
          currentRenderedContent = displayContent;
          content.innerText = displayContent;
          break;
      }
    } else if (mode === "branch") {
      if (!currentBranchNode) {
        content.innerHTML = "<div style='color: var(--text-secondary); text-align: center; padding: 40px; font-style: italic;'>Select a node first to view branch conversation.</div>";
        return;
      }
      
      switch(currentSubMode) {
        case "markdown":
          // Generate markdown version of branch conversation
          const ancestors = currentBranchNode.ancestors();
          const reversedAncestors = ancestors.slice().reverse();
          
          let markdownContent = "";
          reversedAncestors.forEach((n, index) => {
            const data = n.data;
            const msg = extractText(data.rawMessage);
            if (!msg || msg.trim() === "") return;
            
            const role = data.role || "unknown";
            const roleIcon = role === 'user' ? 'ðŸ‘¤' : role === 'assistant' ? 'ðŸ¤–' : 'âš™ï¸';
            markdownContent += `## ${index + 1}. ${roleIcon} ${role} ${data.id || ''}\n\n`;
            markdownContent += `${msg}\n\n---\n\n`;
          });
          displayContent = markdownContent;
          currentRenderedContent = displayContent;
          content.innerText = displayContent;
          break;
        case "rendered":
          const branchHtml = getBranchConversation(currentBranchNode);
          displayContent = branchHtml;
          currentRenderedContent = branchHtml;
          content.innerHTML = branchHtml;
          break;
        case "html":
          const branchHtml2 = getBranchConversation(currentBranchNode);
          displayContent = branchHtml2;
          currentRenderedContent = branchHtml2;
          content.innerText = branchHtml2;
          break;
        case "original":
          // Show original data for the entire branch
          const branchData = [];
          const branchAncestors = currentBranchNode.ancestors();
          const reversedBranchAncestors = branchAncestors.slice().reverse();
          
          reversedBranchAncestors.forEach(n => {
            branchData.push({
              id: n.data.id,
              role: n.data.role,
              text: extractText(n.data.rawMessage),
              rawData: n.data.rawMessage || n.data._original_data
            });
          });
          displayContent = JSON.stringify(branchData, null, 2);
          currentRenderedContent = displayContent;
          content.innerText = displayContent;
          break;
      }
    }
  }

  /* COPY BUTTON */
  document.getElementById("copyBtn").onclick = async () => {
    try{
      await navigator.clipboard.writeText(currentRenderedContent);
      const btn = document.getElementById("copyBtn");
      btn.innerText = "Copied!";
      setTimeout(() => btn.innerText = "Copy", 1200);
    }catch{
      alert("Copy failed");
    }
  };

  /* EXPORT BUTTON */
  document.getElementById("exportBtn").onclick = () => {
    let filename = "";
    let content = "";
    let type = "";

    if (currentMode === "node") {
      if (currentSubMode === "markdown"){
        filename = "node_message.md";
        content = currentRenderedContent;
        type = "text/markdown";
      }else if (currentSubMode === "rendered"){
        filename = "node_message.html";
        content =
          "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Node Message Export</title>\n<style>body { font-family: 'Segoe UI', sans-serif; padding: 20px; background: #f8f9fa; } .message { margin: 20px 0; padding: 15px; border-radius: 10px; } .user-message { background: #e3f2fd; border-left: 4px solid #1976d2; } .assistant-message { background: #f1f8e9; border-left: 4px solid #388e3c; } pre { background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 8px; overflow-x: auto; }</style></head>\n<body>\n" +
          currentRenderedContent +
          "\n</body>\n</html>";
        type = "text/html";
      }else if (currentSubMode === "html"){
        filename = "node_message.html";
        content = currentRenderedContent;
        type = "text/html";
      }else if (currentSubMode === "original"){
        filename = "node_original.json";
        content = currentRenderedContent;
        type = "application/json";
      }
    } else if (currentMode === "branch") {
      if (currentSubMode === "markdown"){
        filename = "branch_conversation.md";
        content = currentRenderedContent;
        type = "text/markdown";
      }else if (currentSubMode === "rendered"){
        filename = "branch_conversation.html";
        content =
          "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Branch Conversation Export</title>\n<style>body { font-family: 'Segoe UI', sans-serif; padding: 20px; background: #f8f9fa; } .message { margin: 20px 0; padding: 15px; border-radius: 10px; } .user-message { background: #e3f2fd; border-left: 4px solid #1976d2; } .assistant-message { background: #f1f8e9; border-left: 4px solid #388e3c; } pre { background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 8px; overflow-x: auto; }</style></head>\n<body>\n" +
          currentRenderedContent +
          "\n</body>\n</html>";
        type = "text/html";
      }else if (currentSubMode === "html"){
        filename = "branch_conversation.html";
        content = currentRenderedContent;
        type = "text/html";
      }else if (currentSubMode === "original"){
        filename = "branch_original.json";
        content = currentRenderedContent;
        type = "application/json";
      }
    }

    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.click();

    URL.revokeObjectURL(url);
  };

  /* PDF EXPORT BUTTON */
  document.getElementById("pdfBtn").onclick = async () => {
    try {
      const content = document.getElementById("viewerContent");
      const buttons = document.getElementById("pdfBtn");
      buttons.innerText = "Generating PDF...";
      
      // Use html2canvas to capture the content
      const canvas = await html2canvas(content, {
        scale: 2,
        useCORS: true,
        logging: false,
        backgroundColor: "#ffffff"
      });
      
      const imgData = canvas.toDataURL('image/png');
      const pdf = new jspdf.jsPDF('p', 'mm', 'a4');
      
      const imgWidth = 190; // A4 width in mm (210mm minus margins)
      const pageHeight = 280; // A4 height in mm (297mm minus margins)
      const imgHeight = canvas.height * imgWidth / canvas.width;
      
      let heightLeft = imgHeight;
      let position = 10; // Start position
      
      pdf.addImage(imgData, 'PNG', 10, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
      
      // Add new pages if content is longer than one page
      while (heightLeft > 0) {
        position = heightLeft - imgHeight;
        pdf.addPage();
        pdf.addImage(imgData, 'PNG', 10, position, imgWidth, imgHeight);
        heightLeft -= pageHeight;
      }
      
      // Generate filename
      let filename = "";
      if (currentMode === "node") {
        filename = `node_${currentNodeData.id || "message"}_${currentSubMode}.pdf`;
      } else {
        filename = `branch_${currentBranchNode?.data?.id || "conversation"}_${currentSubMode}.pdf`;
      }
      
      pdf.save(filename);
      buttons.innerText = "PDF";
      
    } catch (error) {
      console.error("PDF generation error:", error);
      alert("Failed to generate PDF. Please try again.");
      document.getElementById("pdfBtn").innerText = "PDF";
    }
  };

  /* RESET LAYOUT */
  document.getElementById("resetLayoutBtn").onclick = () => {
    allNodes.forEach(n => {
      n.x = n.data.originalX;
      n.y = n.data.originalY;
    });

    updatePositions();
    updateTextPositions();
    fitView();
    updateMinimap();
    clearHighlight();
    clearSearchMatches();
  };

  /* FIT VIEW */
  function fitView(){
    if (!g || !g.node()) return;
    const bounds = g.node().getBBox();
    const svgEl = document.getElementById("graph");

    const t = d3.zoomIdentity
      .translate(svgEl.clientWidth / 2 - (bounds.x + bounds.width / 2), 80)
      .scale(0.85);

    svg.call(zoom.transform, t);
  }

  /* MINIMAP */
  function updateMinimap(){
    const canvas = document.getElementById("minimap");
    const ctx = canvas.getContext("2d");

    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(1, canvas.clientWidth);
    const h = Math.max(1, canvas.clientHeight);

    if (canvas.width !== Math.floor(w * dpr) || canvas.height !== Math.floor(h * dpr)){
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
    }

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, w, h);

    if (!g || !g.node()) return;

    const bounds = g.node().getBBox();
    if (!bounds.width || !bounds.height) return;

    const scale = Math.min(w / bounds.width, h / bounds.height);

    // Draw a subtle background
    ctx.fillStyle = currentTheme === 'light' ? 'rgba(0, 0, 0, 0.03)' : 'rgba(255, 255, 255, 0.1)';
    ctx.fillRect(0, 0, w, h);

    // Draw links
    ctx.strokeStyle = currentTheme === 'light' ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1;
    
    allLinks.forEach(link => {
      const sourceX = (link.source.x - bounds.x) * scale;
      const sourceY = (link.source.y - bounds.y) * scale;
      const targetX = (link.target.x - bounds.x) * scale;
      const targetY = (link.target.y - bounds.y) * scale;
      
      ctx.beginPath();
      ctx.moveTo(sourceX, sourceY);
      ctx.lineTo(targetX, targetY);
      ctx.stroke();
    });

    // Draw nodes with beautiful colors
    allNodes.forEach(n => {
      const x = (n.x - bounds.x) * scale;
      const y = (n.y - bounds.y) * scale;
      const radius = 3;

      if (isSystemData(n.data)) {
        ctx.fillStyle = currentTheme === 'light' ? 'rgba(102, 102, 102, 0.5)' : 'rgba(102, 102, 102, 0.7)';
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      } else if (n.data.role === "user") {
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, '#3B82F6');
        gradient.addColorStop(1, '#1D4ED8');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      } else if (n.data.role === "assistant") {
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, '#10B981');
        gradient.addColorStop(1, '#0C7A5C');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      } else {
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, '#8B5CF6');
        gradient.addColorStop(1, '#6D28D9');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    // Draw viewport rectangle
    const transform = d3.zoomTransform(svg.node());
    const viewportX = (-transform.x / transform.k - bounds.x) * scale;
    const viewportY = (-transform.y / transform.k - bounds.y) * scale;
    const viewportWidth = (w / transform.k) * scale;
    const viewportHeight = (h / transform.k) * scale;
    
    ctx.strokeStyle = 'rgba(255, 193, 7, 0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(viewportX, viewportY, viewportWidth, viewportHeight);
    ctx.setLineDash([]);
  }

  /* PANEL DRAGGING SYSTEM */
  let branchIndexOffsetX = 0;
  let branchIndexOffsetY = 0;

  // Update branch index position when panels are dragged
  function updateBranchIndexPosition() {
    const branchIndex = document.getElementById('branchIndexContainer');
    const rightViewer = document.getElementById('rightViewer');
    const rightViewerRect = rightViewer.getBoundingClientRect();
    
    // Position index to the left of the right panel with some margin
    branchIndex.style.right = (window.innerWidth - rightViewerRect.left + 15) + "px";
  }

  // LEFT PANEL - UPDATED TO PREVENT SEARCH BOX OVERFLOW
  (function(){
    const sidebar = document.getElementById("leftSidebar");
    const handle = document.getElementById("leftDragHandle");
    const graph = document.getElementById("graph");
    const searchContainer = document.getElementById("searchContainer");
    const searchBar = document.getElementById("searchBar");

    let isDown = false;

    handle.addEventListener("mousedown", () => isDown = true);
    window.addEventListener("mouseup", () => isDown = false);

    window.addEventListener("mousemove", (e) => {
      if (!isDown) return;

      const newWidth = Math.max(180, Math.min(500, e.clientX));
      sidebar.style.width = newWidth + "px";

      // Ensure search bar stays within the panel with proper width calculation
      const padding = 15; // Account for sidebar padding
      const searchBarWidth = newWidth - (2 * padding) - 24; // Subtract padding and account for scrollbar
      searchBar.style.width = Math.max(100, searchBarWidth) + "px";

      graph.style.left = newWidth + "px";
      graph.style.width = "calc(100vw - " + newWidth + "px - " + document.getElementById("rightViewer").offsetWidth + "px)";
      
      updateBranchIndexPosition();
      updateMinimap();
    });
  })();

  // RIGHT PANEL
  (function(){
    const viewer = document.getElementById("rightViewer");
    const handle = document.getElementById("rightDragHandle");
    const graph = document.getElementById("graph");

    let isDown = false;

    handle.addEventListener("mousedown", () => isDown = true);
    window.addEventListener("mouseup", () => isDown = false);

    window.addEventListener("mousemove", (e) => {
      if (!isDown) return;

      const screenW = window.innerWidth;
      const newWidth = Math.max(280, Math.min(600, screenW - e.clientX));

      viewer.style.width = newWidth + "px";
      graph.style.width =
        "calc(100vw - " + newWidth + "px - " + document.getElementById("leftSidebar").offsetWidth + "px)";
      
      updateBranchIndexPosition();
      updateMinimap();
    });
  })();

  // Initialize branch index position
  window.addEventListener('load', updateBranchIndexPosition);
  window.addEventListener('resize', updateBranchIndexPosition);

  /* POPOUT VIEWER BUTTON */
  function escapeHtml(s){
    return String(s)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  }

  document.getElementById("popoutBtn").onclick = () => {
    const popup = window.open("", "_blank", "width=900,height=1000");
    if (!popup) return;

    let bodyContent = "";
    let title = "";

    if (currentMode === "node") {
      title = "Node Message";
      if (currentSubMode === "rendered" || currentSubMode === "branch") {
        bodyContent = currentRenderedContent;
      } else {
        bodyContent = '<pre style="white-space: pre-wrap; font-family: monospace; font-size: 14px;">' + escapeHtml(currentRenderedContent) + "</pre>";
      }
    } else {
      title = "Branch Conversation";
      if (currentSubMode === "rendered") {
        bodyContent = currentRenderedContent;
      } else {
        bodyContent = '<pre style="white-space: pre-wrap; font-family: monospace; font-size: 14px;">' + escapeHtml(currentRenderedContent) + "</pre>";
      }
    }

    popup.document.write(`<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>${title} - Pop-Out</title>
<style>
  body { font-family: 'Segoe UI', sans-serif; padding: 20px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); }
  .message { margin: 20px 0; padding: 15px; border-radius: 10px; }
  .user-message { background: linear-gradient(to right, rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.05)); border-left: 4px solid #1976d2; }
  .assistant-message { background: linear-gradient(to right, rgba(16, 163, 127, 0.1), rgba(16, 163, 127, 0.05)); border-left: 4px solid #388e3c; }
  pre { background: linear-gradient(to right, #2c3e50, #34495e); color: #ecf0f1; padding: 15px; border-radius: 8px; overflow-x: auto; font-family: 'JetBrains Mono', 'Consolas', monospace; }
  .code-copy-btn { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); border: 1px solid rgba(0,0,0,0.2); border-radius: 6px; padding: 6px 12px; font-size: 12px; color: #2c3e50; cursor: pointer; font-weight: 600; }
  .code-copy-btn:hover { background: rgba(76, 175, 80, 0.9); color: white; }
  .code-block-wrapper { position: relative; }
</style>
</head>
<body>
${bodyContent}
</body>
</html>`);

    popup.document.close();
  };

  // Initialize collapsible sections
  initializeCollapsibleSections();
  
  // Initialize theme system
  initializeThemeSystem();
  
  // Initialize developer tools
  initializeDeveloperTools();
  
  // Initialize with node mode
  switchMode("node", "rendered");
  </script>
</body>
</html>
